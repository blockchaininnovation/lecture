<center>
  **ZkEvm: スマートコントラクトにロールアップを**
</center>

ZKEVMは、Ethereumでサポートされているようなトランザクションのまとまりに対してゼロ知識証明を用いて暗号学的な証明を作る取り組みです。Ethereumのノードは、EVMの全てのトランザクションを検証しなければならず、新たに加えられたノードも全てのトランザクションを検証する必要があるためネットワークが成長するとともに新しいノードが必要な作業も増加します。そのためEthereumのブロックに対して証明を生成することでこの作業量の増加に対処します。

`Writer: @ashWhiteHat`

- [ZkEvmとは何か？](#zkevmとは何か)
  - [型1（Ethereum完全互換）](#型1ethereum完全互換)
    - [メリット：完全互換](#メリット完全互換)
    - [デメリット：長い証明生成時間](#デメリット長い証明生成時間)
    - [プロジェクト](#プロジェクト)
  - [型2（EVM完全互換）](#型2evm完全互換)
    - [メリット：VMレベルでの完全互換](#メリットvmレベルでの完全互換)
    - [デメリット：少し改善されたが長い証明生成時間が必要](#デメリット少し改善されたが長い証明生成時間が必要)
    - [プロジェクト](#プロジェクト-1)
  - [型2.5（ガス代以外のEVM完全互換）](#型25ガス代以外のevm完全互換)
  - [型3（EVM大部分互換）](#型3evm大部分互換)
    - [メリット：開発の簡易化と証明生成時間の改善](#メリット開発の簡易化と証明生成時間の改善)
    - [デメリット：互換性が少ない](#デメリット互換性が少ない)
    - [プロジェクト](#プロジェクト-2)
  - [型4（スマートコントラクト言語互換）](#型4スマートコントラクト言語互換)
    - [メリット：証明生成時間が速い](#メリット証明生成時間が速い)
    - [デメリット：互換性が少ない](#デメリット互換性が少ない-1)
    - [プロジェクト](#プロジェクト-3)
  - [ZkEvmの設計（Privacy and Scaling Explorations）](#zkevmの設計privacy-and-scaling-explorations)
    - [ZkEvmの課題](#zkevmの課題)
    - [ZkEvmの課題の解決](#zkevmの課題の解決)
      - [Recursion](#recursion)
      - [Lookup](#lookup)
      - [最新のアプローチ](#最新のアプローチ)
    - [ZkEvmの現状](#zkevmの現状)
    - [計算量](#計算量)
    - [費用](#費用)
    - [結論](#結論)
- [まとめ](#まとめ)
- [参照](#参照)

# ZkEvmとは何か？

Ethereumのブロックチェーンで実現されている機能性をスケーラブルにする取り組みであり、以下のどれかに該当する

- ZK-SNARKを用いてEthereumでサポートされているようなトランザクションに暗号学的な証明を作る
- Ethereum自体の検証より簡単にする
- Ethereumが提供している機能と同じかそれに近い機能にZK-Rollupsを構築する

これらのプロジェクトは実現可能性と速度のトレードオフによって異なっている。  
ZkEvmは利便性とコストの観点から4つの型に分けることができる。

![型](./img/types.png)

| 型 | Ethereum互換 | EVM互換（ガス代含め） | EVM互換（ガス代以外） | EVM互換（複雑箇所以外） | スマートコントラクト言語互換 | 最適化戦略 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | ✓ | ✓ | ✓ | ✓ | ✓ | なし |
| 2 | × | ✓ | ✓ | ✓ | ✓ | ブロック構造や状態管理の削除またはゼロ知識証明に適したものへの変更 |
| 2.5 | × | × | ✓ | ✓ | ✓ | ゼロ知識証明に適さない処理への制約やガスコストの値上げ |
| 3 | × | × | × | ✓ | ✓ | プレコンパイルや記憶領域など難易度の高い実装の省略または変更 |
| 4 | × | × | × | × | ✓ | Ethereumのスマートコントラクト言語をより効率的な言語へトランスパイル |

## 型1（Ethereum完全互換）

この型は、Ethereumとの完全互換を目指している。  
証明生成を簡単にするためにEthereumのシステムを変更しない。  
以下に付随的なものであってもハッシュ関数やステートツリーやトランザクション手数料、プレコンパイルやコンセンサスに関わる機能を置き換えることはしない。

### **メリット：完全互換**

目標は、現在のEthereumのブロックの検証を可能にしすることである。  
究極的にはEthereumのL1をよりスケーラブルにするために必要なことであり、長期においては他の型での実装によってEthereumを再設計する可能性もある。  
この型1は様々なインフラに用いることができるため理想的なロールアップである。  
ブロックチェーンエクスプローラなどのEthereumのエコシステムのツールを簡単に使い回すことができる。

### **デメリット：長い証明生成時間**

Ethereumは元々、ゼロ知識証明を前提として設計されたものではないためゼロ知識証明の証明の生成に多くの時間がかかってしまう。  
型1は、Ethereumの完全互換を目的としているため非効率性を受け入れるしかない。  
現時点では、Ethereumブロックへの証明には数時間かかる。  
証明生成の並列化や長期ではZK-SNARKの仕様によって改善される。

### **プロジェクト**
- [Privacy and Scaling Explorations](https://github.com/privacy-scaling-explorations/zkevm-circuits)
- [Taiko](https://taiko.xyz/)

## 型2（EVM完全互換）

この型は、EthereumではなくEVMとの完全互換を目指している。  
内部からはEthereumのように見えるが、外部にはブロック構造やステートツリーなどに違いがある。  
目標は既存のアプリケーションとの完全互換であるが、開発工数短縮や証明生成の簡易化のためEthereumに微修正を加えている。

### **メリット：VMレベルでの完全互換**

型2は、Ethereumの状態を保持するデータ構造に変更を加えている。  
しかし、それらのデータ構造にはEVMから直接アクセスすることはできないためほとんどのアプリケーションと互換性がある。  
Ethererumの実行クライアントをそのまま使うことはできないが、少し修正を加えることで使うことができる。  
EVMの開発環境やその他のエコシステムはこれまでと同じように使うことができる。

例外として、ハッシュ関数が効率の良いものに変更されているため、従来のブリッジなどで用いられるブロックのマークルツリーを検証し、過去のトランザクションやステートを検証することはできない。

### **デメリット：少し改善されたが長い証明生成時間が必要**

型2は、Ethereumの不要な箇所やゼロ知識証明に適していない要素を取り除くことで型1より速い証明生成を実現した。  
具体的には、KeccakハッシュやRLPを使ったマークルパトリシアツリー、ブロックやトランザクションレシートの構造など。  
型2は、ポセイドンハッシュというゼロ知識証明に適したハッシュ関数を用いているため、Keccakハッシュに関する`EXTCODEHASH`や`EXTCODECOPY`などのオペコードは置き換えられている。

これらの変更によって証明生成にかかる時間を大きく削減したが、EVM自体の証明にはゼロ知識証明に適していない箇所が存在し、いまだに長い証明時間が必要。

### **プロジェクト**
- [Scroll](https://scroll.mirror.xyz/)
- [Polygon Hermez](https://hermez.io/)

どちらのプロジェクトも現時点ではプレコンパイルなどの複雑な箇所は実装されていないため型3と考える方が妥当である。

## 型2.5（ガス代以外のEVM完全互換）

最悪の場合の証明生成時間の改善方法としてゼロ知識証明に適していないEVMのオペコードのガスコストを上げるというものがある。  
これは、プレコンパイルやKeccakのオペコードやコントラクトの特定の呼び出し方や記憶領域へのアクセスなどの処理の実行である。  
ガスコストを変更することで開発ツールの互換性を損ねたりアプリケーションが動作しなくなることが考えられるが、より深部のEVMの変更に比べると一般的には低リスクと考えられる。

別の方法としてリソースの制約の管理を行う方法がある。  
これはそれぞれの処理で呼び出すことができる回数を制限するという簡単なものである。  
簡単に実装できる反面、EVMのセキュリティの仮定には良くない影響がある。

これらのアプローチを型3ではなく型2.5と呼ぶ。

## 型3（EVM大部分互換）

型3は、ほぼEVM互換であるが開発工数と証明生成時間の短縮のため完全互換を犠牲にしている。

### **メリット：開発の簡易化と証明生成時間の改善**

ZkEvmを実装する上で例外的に難しい箇所を削除している。  
プレコンパイルがこれに該当し、記憶領域のコントラクトコードやメモリ、スタックなどの扱いが異なる場合がある。

### **デメリット：互換性が少ない**

目標は、ほとんどのアプリケーションと互換性があることと最小限の変更で動作可能にすること。  
いくつかのアプリケーションはプレコンパイルを含む場合は削除するか、ZkEvmで扱いの異なる実装に依存をしていた場合は再度の開発が必要。

### **プロジェクト**

現在のScrollやPolygonが該当する。  
型3は、あまり好まれることはなくマイルストーンの一部として置かれることが多い。

## 型4（スマートコントラクト言語互換）

型4は、スマートコントラクト言語で記述された言語か、中間言語をゼロ知識証明に適した設計の別の言語にコンパイルする。

### **メリット：証明生成時間が速い**

EVMをゼロ知識証明で証明する際に必要であった多くのオーバーヘッドを別の言語にコンパイルすることで大幅に削減することが可能となる。  
別言語へコンパイルし、証明者の大幅なコストの削減が見込めるため分散化に大きく貢献している。

### **デメリット：互換性が少ない**

VyperやSolidityの言語で書かれたアプリケーションは動作するが多くの点で通常の通りの動作ではない。

- **コントラクトアドレス**：`CREATE2`のオペコードではコントラクトアドレスはバイトコードに依存しているため同じアドレスを再現することができない。これはデプロイされていないコントラクトを前提としたERC-4337ウォレットやEIP-2470などのアプリケーションが動作しないことを意味する。
- **バイトコード開発**：型4では、言語レベルの互換はあるがバイトコードレベルでの互換はサポートされていないためバイトコードを直接開発することはできない。
- **開発環境**：デバッグツールなどはEVMバイトコードを動かしているため現在、エコシステム内で用いられている開発ツールをそのまま使うことはできない。

### **プロジェクト**
- [ZKSync](https://zksync.io/)
- [Warp](https://warpgate.pro/)

# ZkEvmの設計（Privacy and Scaling Explorations）

Privacy and Scaling ExplorationsがどのようにEthereum互換のZkEvmを実現しようとしているかを解説する。  
EVMの実行の正当性を保証するためには、主に3つのことを証明しなくてはならない。  

1. オペコードのロジックが正しく実行されたこと
2. オペコードが正しい順番で呼び出されたこと
3. オペコードのコンピューターのリソースへの読み書きが正しく行われたこと

開発の簡易化の観点から証明は2つに分けられる。

- 状態証明：ストレージ、メモリやスタックが正しく実行されたことを証明する。正しい位置の読み書きが行われたかの検証はEVM証明で行われる。
- EVM証明：オペコードが正しい順番で正しいロジックを実行したことを証明する。

これらの2つの証明を用いることでEVMの実行の正当性を保証する。
<!-- 
具体的な処理と証明方法を例示したい．

例えば適当な関数例とそれをバイトコードにコンパイルされ，OP_CODEに分解されるところの例示と，そのOP_CODEまで分解された状態でどのようにZKの回路に入れるのか，まで．

例えば以下ChatGPTによる出力．おかしいところは要修正．
 -->

例えば
```solidity
function add(uint a, uint b) public returns (uint256) {
    return a + b;
}
```
の関数をもとにSolidityコンパイラを使って，EVMバイトコードに変換．
```
0x608060405234801561001057600080fd5b506040516020806101238339810180604052810190808051820192919050505b806000819055505b6100d5806100566000396000f3fe
```
これは，以下のようにEVMの命令セット（OP_CODE）に分解できる．
バイトコード中のオペコードとその役割：
    6080 - PUSH1 0x80
    これはスタックに値0x80をプッシュするオペコードです。スタック操作の一部で、メモリ管理やエラー処理のために使われる。

    6040 - PUSH1 0x40
    スタックに値0x40をプッシュします。メモリ領域の操作に関連する。

    52 - MSTORE
    PUSH1 0x40で指定されたメモリ位置に0x80をストアします。これにより、メモリの一部が予約されます。

    34 - CALLVALUE
    トランザクションで送信されたEtherの量を取得します。一般的に、関数がパブリックでEtherを受け取れる場合に使われる。

    80 - DUP1
    スタックの最上位の値を複製し、再度スタックにプッシュします。

    61 0010 - PUSH2 0x0010
    スタックに0x0010をプッシュします。次のジャンプ先のアドレスを示します。

    57 - JUMPI
    条件付きでジャンプを実行します。特定の条件が満たされた場合に0x0010にジャンプします。

    fd - REVERT
    エラーが発生した場合の処理を行い、状態をロールバックします。

    5b - JUMPDEST
    ジャンプ先のアドレスをマークします。

    50 - POP
    スタックから最上位の値を取り除きます。

このように、バイトコードはEVM命令セットで構成されており、EVMはこれを順に解釈して実行します。


zkEVMでの動作

上記のオペコードがzkEVM上で実行される際、zkEVMは以下のようにその正当性を保証します。

    オペコードの正当性証明（EVM証明）
    各オペコードが、対応する処理を正しく実行したことを証明します。例えば、PUSH1が正しい値をスタックにプッシュしたか、MSTOREがメモリに正しく書き込んだかを検証します。

    状態証明
    スタック、メモリ、ストレージなどの状態がオペコード実行後に正しく更新されたことを証明します。例えば、a + bの加算処理が実行された後、その結果がスタックやメモリに正しく反映されたかを検証します。

これにより、zkEVMは通常のEVMと同様にバイトコードを実行できるだけでなく、その過程で行われたすべての計算が正しいものであることを暗号学的に証明することができます。

<!-- 
これらの2つの証明をZKの回路でどうやっているのか，説明を加えてください．
たぶん，オペレータは，実行するコントラクトのEVMバイナリをプライベートインプットに，ユーザーのTxをパブリックインプットに，ステートをパブリックインプットに入れて，その実行結果のステートをアウトプットに出しているのでは？と想像しています．

で，その1Txあたりの処理のプルーフをまとめ上げてRollupしているところも入出力が何なのかを分かる形にして，コントラクトにはどういう情報を入力し，管理しているのかも追記してください．
ステートルートや，calldataへのTxリスト，そのTxリスト全体からステートルートが更新されるというプルーフ？
 -->
## ZkEvmの課題

上記の1~3までを実現するにはゼロ知識証明では回路のサイズが大きくなりすぎてしまうという問題が存在した。  
また、オペコードのメモリやスタック等のコンピューターへのリソースのアクセスがランダムに行われることもあるため固定の回路を用いる従来の方法では実現することができなかった。  
この2つの課題に対して新たな手法が取られ解決された。

## ZkEvmの課題の解決

ゼロ知識証明では、コンピュテーションを算術回路と呼ばれる形式に変換し、証明を生成する。この算術回路の長さを削減することが証明生成時間の削減に繋がる。この算術回路の長さの短縮には主に2つのアプローチが取られる。

一つ目は、大きな算術回路をより小さい算術回路に分割し、それぞれの小さいコンピュテーションに対して別々に証明を生成することで証明をする算術回路のサイズの最大値を削減する方法。

二つ目は、コンピュテーションから算術回路に変換をする際にサイズが膨れやすい処理（ZK-Unfriendlyと呼ばれる）を証明生成の前に予め計算し、その予め計算されたデータを証明生成の際に参照することで特定のコンピュテーションによる算術回路の法外な肥大化を防ぐ方法。

一つ目のアプローチを証明を証明するという再帰の関係からRecursionと呼び、二つ目のアプローチを予め計算されているデータを検索参照することからLookupと呼ぶ。

### Recursion

Recursionは大きなコンピュテーションを小さいステップに分割し、順に証明を行うことで証明の生成に必要なデータ量と時間を削減する方法である。

仮にBitcoinの状態遷移が正しく行われたことを証明しようとする。証明を生成する際にはGenesis Blockから現在のブロックまでのトランザクションとブロックの情報が必要となる。また、新たなブロックが追加された場合は再度、Genesis Blockから証明の生成を再計算する必要がある。

Recursionではブロックごとに証明を生成し、新たなブロックに対する証明を作る際に一つ前のブロックに対する証明の正当性も証明する。これにより全体を再計算する必要がなくなり、証明生成に必要なデータと計算量はブロック一つ分となる。

しかし、この証明生成には高負荷な処理が必要であり、また、証明自体の証明も複雑である。より軽量に証明の正当性を検証できるAccumulationというスキーマも開発されたがそれでもZKEVMのような複雑な処理の証明は難しかった。

### Lookup

Lookupはコンピュテーションから算術回路に変換する際に肥大化しやすい処理を予め計算し、参照テーブルを予め計算し、そのデータを証明生成時に参照することで算術回路の肥大化を防ぐ方法である。

ボトルネックとなる処理というのは1ビット単位での制約が必要となるRange Checkやビット演算のXORなどのオペレーションである。また、ZKVMではStackやMemory、Storageなどのリソースへの読み書きの一貫性の証明も必要となるためアクセスレコードをLookup Tableで管理している。

しかし、前述した通り、Lookupでは参照されるデータを予め計算する必要がある。例えば32 bitの数字同士のXORのデータをLookupしたい場合は、それぞれのbitのパターンを全て網羅する必要がありデータのサイズは2³² bit * 2³² bitの2⁶⁴ bitを3列で用意するためおおよそ6000 petabyte (2⁶⁴ * 3)のテーブルが必要になる。ゼロ知識証明の回路では256bit等の大きなデータを扱う。そのため大きいサイズのテーブルへのLookupができないことが問題となった。

Caulk Lookupという技術では、テーブルの代表値をパブリックパラメータとしてコミットすることで、予め行われる計算のコストは削減されたが容量の大きいパラメータをダウンロードしなくてはいけないという制限があった。

この予めの計算に必要なテーブルを構造的な性質を用いてより小さいサイズのテーブルに分解し、データサイズを削減したものがLassoである。また、Lassoでは、Lookupの証明に適した制約表現が用いられており、Lookupの証明コストも従来の制約表現に比べて削減されているのが特徴である。

### 最新のアプローチ

Recursionを行う際に、証明の生成には高負荷な処理が必要となるため、証明を生成するのではなく証明しようとする命題を圧縮しようというアプローチがFoldingである。小さく分けられたコンピュテーションの全てに証明を生成するのではなく、分けられたコンピュテーション自体を圧縮し、圧縮されたコンピュテーションに対して証明を生成することで高負荷な処理を避けつつコンピュテーション全体を証明することができる。

FoldingはNovaの論文で提案され、SuperNova、HyperNovaとアップデートされている。主な違いはNovaは特定のコンピュテーションに対するFoldingであったのに対し、SuperNovaでは任意のコンピュテーションに対するFoldingが可能となりHyperNovaでは証明可能な制約表現の種類がR1CSに限らずAIRやPlonkArithmetizationの表現も利用できるようになった。

LookupではTableの前計算という作業が発生する。この予めの計算に必要なテーブルを構造的な性質を用いてより小さいサイズのテーブルに分解し、データサイズを削減したものがLassoである。また、Lassoでは、Lookupの証明に適した制約表現が用いられており、Lookupの証明コストも従来の制約表現に比べて削減されているのが特徴である。

また、重要な概念としてLookup Singularityがある。Lookup Singularityとは、ゼロ知識証明を全てLookupで行おうという考え方である。Lookupは従来のゼロ知識証明で制約を表現するより簡潔で計算量も少ないため、ゼロ知識証明を用いる際に低レベルの知識なしで開発を行うことができることやコード監査の複雑性を抑えることができる。そのためスケーリング技術において発生するあらゆるコストを削減することができる。

## ZkEvmの現状

ZKEvmはスケーリング技術であるため、観点は計算量、費用を鑑みた上で有意にユーザーのトランザクションコストを削減できているかという点で評価する。

### 計算量

現時点で利用できるライブラリでは、通常の通りにVMを実行した場合に比べ証明を生成する場合では約百万から一億倍の計算量のオーバーヘッドが発生する。証明生成の作業は一つのノードで行うことができ、Ethereumのノード数は95万ノードであるためオーバーヘッドを95万倍以下に抑えなければ本末転倒となる。

### 費用

Evmのオペコードに対してゼロ知識証明言語で制約を記述する必要があるためソフトウェアのアップデートの度に、開発・監査・メンテナンスのコストがかかる。また、メインチェーンには代表値のみを書き込むためデータアベイラビリティに必要なデータベースのバックアップやオペレーターノードの運用の費用がかかる。

### 結論

総合的に考えると現時点では、Ethereumのバリデーター数を考えるとスケーラビリティへの対策としてはギリギリ有効であるが開発工数などを考えるとコストの方が高くなるのではないかと推測する。

Lookup Singularityが実現された場合は、証明生成のオーバーヘッドが楽観的な見積もりで40分の1ほどになる。また、開発・監査・メンテナンスのコストが大幅に軽減されるためZkEvmの利用が現実的になるのではないかと思われる。

しかし、現在提案されているスキーマは、データが構造的である場合にのみテーブルのダウンサイジングが可能であるため全ての処理をLookupに置き換えるには別のスキーマが提案される必要があるのではないかと思う。

# まとめ

現在、様々なプロジェクトがZkEvmを実現に取り組んでいる。  
それぞれのプロジェクトに違いを生んでいるのは互換性と開発工数や証明時間に関連した実現可能性のトレードオフの捉え方である。  
多くの互換性を保証することでエコシステムで用いられている開発ツールやセキュリティのノウハウを再利用することができるが、ゼロ知識証明に適した設計ではないため開発の長期化や証明生成のオーバーヘッドが増加する。  
開発や証明生成の観点から機能の削減や効率化を行うと互換性を失い、エコシステムの開発ツールやセキュリティのノウハウを再利用することができなくなり、Ethereumから移植する作業の際にも修正を行う工数が発生する。  
メリットとデメリットが存在するため、ZkEvmの開発者と利用者はそれぞれの違いを留意することが重要である。

# 参照

- [The different types of ZK-EVMs](https://vitalik.eth.limo/general/2022/08/04/zkevm.html)
- [Zkevm Specifications](https://github.com/privacy-scaling-explorations/zkevm-specs)
- [Privacy and Scaling Explorations](https://github.com/privacy-scaling-explorations/zkevm-circuits)
- [Taiko](https://taiko.xyz/)
- [Scroll](https://scroll.mirror.xyz/)
- [Polygon Hermez](https://hermez.io/)
- [ZKSync](https://zksync.io/)
- [Warp](https://warpgate.pro/)
- [Brief Introduction of Latest Zero Knowledge Proof such as ZKVM, Recursion and Lookup](https://medium.com/coinmonks/brief-introduction-of-latest-zero-knowledge-proof-such-as-zkvm-recursion-and-lookup-9cbc60215a47)
- [Proof-Carrying Data without Succinct Arguments](https://www.youtube.com/watch?v=hdmR4wSwryQ)
- [Demystifying recursive zero-knowledge proofs](https://anoma.net/blog/demystifying-recursive-zero-knowledge-proofs)
- [Understanding Lasso and Jolt, from theory to code](https://a16zcrypto.com/posts/article/building-on-lasso-and-jolt/)
- [An incomplete guide to Folding: Nova, Sangria, SuperNova, HyperNova, Protostar](https://taiko.mirror.xyz/tk8LoE-rC2w0MJ4wCWwaJwbq8-Ih8DXnLUf7aJX1FbU)
- [Lookup Singularity](https://zkresear.ch/t/lookup-singularity/65)
- [Lasso, Jolt, and the Lookup Singularity, Part I with Justin Thaler | a16z crypto research talks](https://www.youtube.com/watch?v=aEiHLORcDq4)
- [Lasso, Jolt, and the Lookup Singularity, Part II with Justin Thaler | a16z crypto research talks](https://www.youtube.com/watch?v=dmVweFbJsxw)
- [Visualizing Lasso: A fast new lookup argument for SNARKs](https://www.youtube.com/watch?v=iDcXj9Vx3zY)