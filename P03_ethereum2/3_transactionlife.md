- [トランザクションのライフサイクル](#トランザクションのライフサイクル)
  - [EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する](#eoaはトランザクションmessage-call-or-contract-creationを各ノードに伝搬する)
  - [各ノードは、受け取ったトランザクションを独立に検証する](#各ノードは受け取ったトランザクションを独立に検証する)
  - [各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する](#各ノードは問題が無いトランザクションのみを溜めかつ他のノードに伝搬する)
  - [バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる](#バリデータノードたちは確率的にブロックの提案-or-投票ノードに選ばれる)
    - [PoWからPoSへ](#powからposへ)
    - [SlotとEpoch](#slotとepoch)
    - [提案ノードの選択](#提案ノードの選択)
    - [投票ノードの選択](#投票ノードの選択)
    - [補足: どのように「確率的に」選択するのか](#補足-どのように確率的に選択するのか)
  - [投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する](#投票ノードたちは正統と考えるチェーンの先端にあるブロックを宣言する)
  - [提案ノードは、任意のトランザクションおよび宣言をブロックに格納する](#提案ノードは任意のトランザクションおよび宣言をブロックに格納する)
    - [Ethereumブロックのデータ構造](#ethereumブロックのデータ構造)
      - [Execution payload headerのデータ構造](#execution-payload-headerのデータ構造)
    - [Block Gas Limitについて](#block-gas-limitについて)
    - [baseFeePerGasの決定ルールについて](#basefeepergasの決定ルールについて)
    - [State Root, Receipts Rootについて](#state-root-receipts-rootについて)
    - [データ構造を実際に確認してみましょう](#データ構造を実際に確認してみましょう)
  - [提案ノードは、ブロック内のトランザクションを実行する](#提案ノードはブロック内のトランザクションを実行する)
  - [提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ](#提案ノードはブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ)
  - [提案ノードは、完成したブロックを各ノードに伝搬する](#提案ノードは完成したブロックを各ノードに伝搬する)
  - [各ノードは、受け取ったブロックに問題が無いかを独立に検証する](#各ノードは受け取ったブロックに問題が無いかを独立に検証する)
  - [各ノードは、問題が無いブロックのみを自身のチェーンに反映する](#各ノードは問題が無いブロックのみを自身のチェーンに反映する)
  - [バリデータノードたちは、最も重いチェーンを「正しい」状態遷移の記録とする](#バリデータノードたちは最も重いチェーンを正しい状態遷移の記録とする)
    - [Gasperプロトコルについて](#gasperプロトコルについて)
    - [checkpoint, justified, finalizedの定義](#checkpoint-justified-finalizedの定義)
    - [LMD GHOSTについて](#lmd-ghostについて)
    - [Casper FFGについて](#casper-ffgについて)
    - [報酬メカニズム](#報酬メカニズム)
    - [罰則メカニズム　　](#罰則メカニズム)
    - [コンセンサスのまとめ　　       　　](#コンセンサスのまとめ-------)
- [まとめ](#まとめ)


# トランザクションのライフサイクル
 
ここまでEthereumの構成要素を確認してきましたが、これらはどのように連動しているのでしょうか。
あるトランザクションが作成されてから実行され、ブロックチェーンに格納されるまでのライフサイクルを軸に詳細を確認してましょう。

Introductionで示したとおり、トランザクションのライフサイクルは大きく以下のような流れになっている

```
EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する
各ノードは、受け取ったトランザクションを独立に検証する
各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する
バリデータたちは、確率的にブロックの提案者と投票者に選ばれる
投票者は、正統と考えるチェーンの先端にあるブロックを宣言する
提案者は、任意のトランザクションおよび宣言をブロックに格納する
提案者は、ブロック内のトランザクションを実行する
提案者は、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ
提案者は、完成したブロックを各ノードに伝搬する
各ノードは、受け取ったブロックに問題が無いかを独立に検証する
各ノードは、問題が無いブロックのみを自身のチェーンに反映する
バリデータたちは、最も重いチェーンを「正しい」状態遷移の記録とする
```

## [EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する](../P02_ethereum/3_transactionlife.md#EOAは、トランザクション(message-call-or-contract-creation)を各ノードに伝搬する)
以前のEthereumと同様である

## [各ノードは、受け取ったトランザクションを独立に検証する](../P02_ethereum/3_transactionlife.md#各ノードは、受け取ったトランザクションを独立に検証する)
以前のEthereumと同様である

## [各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する](../P02_ethereum/3_transactionlife.md#各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する)
以前のEthereumと同様である


## バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる

### PoWからPoSへ

- Ethereumは2022年8月にブロック作成要件をPoWからPoSへ移行した
  - ``なぜ？: スケーラビリティ問題に対応するため``
  - よってここからBitcoin Protocolと仕様が大きく変わり始める！
- EthereumのPoSは、おおまかには以下の仕組みでブロック作成者を決定する
  - **full (またはarchive) nodeは、自身が管理するEOAからdeposit contractと呼ばれるCAに32ETH以上を預ける (stakeする) ことでバリデータノードになることが出来る**
  - **将来のブロック作成者はバリデータノードの中から定期的に選択される**
  - **このとき以前のブロックに投票するバリデータノードたちも選択される**
  - **上記の選択は確率的だが、各バリデータノードのstake量で重み付けされている**
- つまりBitcoin ProtocolのPoWのように、各ノードが採掘作業を重複して行う必要がない
  - エコ？効率的？

*"PoW vs PoS" はブロックチェーンにおいて最も伝統的な論点の1つであり、現在も様々な観点 (e.g., どちらが公正なのか？ どちらが効率的なのか？ どちらが分散的なのか？ どちらが環境に優しいのか？) で研究・分析が行われています

<!--
詳しくは後述しますが、スケーラビリティ問題に対応するため、Ethereumは2022年8月にブロック作成要件をPoWからPoSへ移行しました.これによって、Bitcoin Protocolと仕様が大きく異なり始めます。

EthereumのPoSは、おおまかには次の仕組みでブロック作成者を決定します。

まず、full (またはarchive) nodeは、自身が管理するEOAからdeposit contractと呼ばれるコントラクトアカウントに32ETH以上を預ける (stakeする) ことでバリデータノードになれます。

将来のブロック作成者はバリデータノードの中から定期的に選択されますが、このとき以前のブロックに投票するバリデータノードたちも選択されます。ここでの選択は確率的に行われますが、選択される確率は各バリデータノードのstake量で重み付けされています。

この仕組みによって、PoWのように、各ノードが`採掘作業を重複して行う必要`がなくなります。そのためネットワークを維持するためのエネルギー消費が抑えられて効率的でエコになります。

しかし、"PoW vs PoS" はブロックチェーンにおいて最も伝統的な論点の1つであり、現在も様々な観点 (e.g., どちらが公正なのか？ どちらが効率的なのか？ どちらが分散的なのか？ どちらが環境に優しいのか？) で研究・分析が引き続き行われています。
-->
 

### SlotとEpoch

Ethereumのブロックチェーンは、12秒をslot、32slot (6.4分) をepochと呼び、slot, epoch単位でブロックの提案や合意形成、報酬などを管理しています。Bitcoin Protocolではslotは (block intervalとして) 約10分になるように設計されていました。Bitcoin Protocolにおけるdifficultyの概念はEthereumには存在しません。

<center>
<img src="./img/slot.drawio.svg" width="90%">
</center>

### 提案ノードの選択

提案ノードの選択は、1つ前のepochのslot 0 時点で一気に行われます。このとき、バリデータのstake量が多いほど選ばれる確率が高くなりますが、32ETHを超えるともう上がらないようになっています。また、詳細は後述しますが、stakeされたETHはペナルティとして一部が没収される可能性があります。したがってバリデータのstake量は (事後的に) 32ETH未満になりえます。

多くのバリデータを管理するノードほど、ブロック提案の権利を得る確率が高まるため、ノードの視点からすれば**32ETHが宝くじ1枚のような扱い**になっています。


### 投票ノードの選択

提案ノードと同様に、epochの各slotに対応するブロック投票者も、1つ前のepochのslot 0 時点で一気に選択されます。1slotにnバリデータ (not バリデータノード) ずつ割り当てられます。このバリデータたちはcommitteeという単位でまとめられ、合意形成に必要な投票を担います。なぜなら、投票の集約はcommittee単位で並列化して行った方が効率的だからです。1slotあたりのcommittee数と1committeeあたりのバリデータ数は、ネットワーク上の総バリデータ数に応じてepoch毎に変動します。最近のnは15,000~20,000あたりです。したがって1epochの間に全バリデータに投票機会があります。

同様に、多くのバリデータを管理するノードほど、ブロック投票の権利を得る確率が高まるため、ノードの視点からすれば**32ETHが宝くじ1枚のような扱い**になっています。


### 補足: どのように「確率的に」選択するのか
- Ethereumで確率的な選択を行うことは結構難しい
  - `なぜ？: 分散的な検証・合意形成のために同じ入力に対して同じ出力が返ってくる必要があるから`
  - つまりスマートコントラクト内で乱数を扱うことができない
  - 復習: EVMも乱数は扱えないようになっていた
  - プロトコル外で生成された乱数を用いる場合は、生成元を信用する必要が生じる
- そこで現在のEthereumは **RANDAO** という仕組みで擬似乱数を生成している
  - 各ブロックに含まれるrandao_revealという値(ブロックを提案するバリデータの署名を元に生成)を用いて、epoch毎に変わる擬似乱数を生成
  - 詳細はややテクニカルなので割愛
- RANDAOによる擬似乱数をシード値に、各ノードのクライアントソフトウェア上でバリデータの確率的な選択が行われている
  - シード値は共通なので選択結果も共通となる

## 投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する

committeeに含まれたバリデータ (実際にはそれを管理するノード) は、正統なブロックチェーンを決めるための投票を行うことが出来る。この投票を集約したものを **attestation (宣言)** と呼ぶ。

- (当然といえば当然だが) 投票は割り当てられたslot以前のブロックチェーンを対象に行われる
- 投票は割り当てられたslot内で行うことが望ましいが、それ以後でも (＋32slotまでなら) 行える
  - e.g., slot6に割り当てられたバリデータは、slot15でslot6以前に関する投票が行える
  - ただしこの場合は報酬が減る(後述)
- 具体的には次の2つを宣言する
  1. 現在どのブロックが先端にあるか？
  2. 現在どのブロックが最新のepochの最初のブロックか？

投票の中身は以下のとおり

| 名称 | 役割 |
| ---- | ---- |
| slot | 割り当てられたslotの番号
| committee_index | そのslotにおける何番目のcommitteeに所属しているか
| beacon_block_root | 先端だと思うブロックのヘッダーのハッシュ
| source | 最新のjustified (後述) されたと思うブロック
| target | 現在のepochで最初にあると思うブロック

- 上記が一致する (異なるバリデータによる) 投票を集約したものがattestationである
  - slot, committee_indexが同じでも、残り3つの情報が異なる場合は別のattestationとして集約される
  - attestationは (トランザクションのように) peer-to-peerネットワークにブロードキャストされる
- 集約には先述の Validator Signing Key を用いる
  - EOAの鍵 (楕円曲線暗号)とは異なる形式 (BLS署名) のため、署名の集約が行える

## 提案ノードは、任意のトランザクションおよび宣言をブロックに格納する

### Ethereumブロックのデータ構造

The Merge以前のブロックはExecution Layerと呼ばれている。
<center>
<img src="../P02_ethereum/img/blockstructure.drawio.svg" width="75%">
</center>

- 直感的には、飛行機が飛びながら別のより大きな飛行機の中に格納されていくイメージ
- だからThe Mergeと呼ばれている
- タイミング的に、提案ノードは同じslotのcommitteeが作成したattestationを格納することはできない
- 提案ノードは、それ以前のattestationを64-128個ブロックに格納することが出来る
- 提案ノードは、attestationの格納数に応じた報酬を獲得できる (後述)

#### Execution payload headerのデータ構造

### [Block Gas Limitについて](../P02_ethereum/3_transactionlife.md#block-gas-limitについて)
以前のEthereumと同様である
### [baseFeePerGasの決定ルールについて](../P02_ethereum/3_transactionlife.md#baseFeePerGasの決定ルールについて)
以前のEthereumと同様である
### [State Root, Receipts Rootについて](../P02_ethereum/3_transactionlife.md#state-root,-receipts-rootについて)
以前のEthereumと同様である

### データ構造を実際に確認してみましょう

ここまで確認してきたようなデータ構造は、[beaconcha.in](https://beaconcha.in/)などのエクスプローラーサイトを通じて直接確認することができます。
この資料で各要素の意味はおおまかに掴めたと思いますので、ぜひ実際の中身を確認してみてください。

<center>
<img src="./img/beacon.png" width="75%">
</center>


## 提案ノードは、ブロック内のトランザクションを実行する

- Bitcoin Protocolと同様、親のブロックヘッダのハッシュを自身のブロックヘッダに格納することでチェーンを形成する 
- ただしThe Mergeを経て...
  - 参照する要素が2種類 (新ブロックヘッダ, execution payload header) に増えた
  - 冗長なので将来的には1つにまとまるかも...


## [提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ](../P02_ethereum/3_transactionlife.md#提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ)
以前のEthereumと同様である (担当者がマイナーノードから提案ノードに変わったという違いはある)

## [提案ノードは、完成したブロックを各ノードに伝搬する](../P02_ethereum/3_transactionlife.md#マイナーノードは、完成したブロックを各ノードに伝搬する)
以前のEthereumと同様である (担当者がマイナーノードから提案ノードに変わったという違いはある)

## [各ノードは、受け取ったブロックに問題が無いかを独立に検証する](../P02_ethereum/3_transactionlife.md#各ノードは、受け取ったブロックに問題が無いかを独立に検証する)
以前のEthereumと同様である

## [各ノードは、問題が無いブロックのみを自身のチェーンに反映する](../P02_ethereum/3_transactionlife.md#各ノードは、問題が無いブロックのみを自身のチェーンに反映する)
以前のEthereumと同様である

## バリデータノードたちは、最も重いチェーンを「正しい」状態遷移の記録とする
- PoSを採用しても、Ethereumのブロックチェーンは分岐する可能性がある
  - ネットワーク上でのブロックの伝搬に遅延が発生した場合
  - 悪意あるブロック提案者が同じslotにおいて2つ以上のブロックを流した場合
  - などなど...

- The Merge後のEthereumも「最も重いチェーン」を正統とするが、先述のGHOSTプロトコルとは異なるアルゴリズムを採用している
- 重いチェーンは **Gasperプロトコル (LMD GHOST + Casper FFG)** で定義されている
  - LMD GHOST: epoch内でブロックチェーンが分岐した場合の「重いチェーン」
  - Casper FFG: epochを跨いでブロックチェーンが分岐した場合の「重いチェーン」

【キャスレー：GHOSTプロトコルとは？どのチェーンをメインチェーンにするかを決定するプロトコル
　Bitcoinとの違い⇒Bitcoinは、一番長いチェーンがメインチェーン。Ethereumは、一番重い(heaviest)チェーン】

- どちらもブロックに含まれる投票 (attestation)を用いて「重いチェーン」を決める
  - 復習: 以前のGHOSTプロトコルでは、子ブロックの数を数えていた

### Gasperプロトコルについて 

復習: 投票において各バリデータが宣言する情報

| 名称 | 役割 | 備考 |
| ---- | ---- | ---- |
| slot | 割り当てられたslotの番号 |
| committee_index | そのslotにおける何番目のcommitteeに所属しているか |
| beacon_block_root | 先端だと思うブロックのヘッダーのハッシュ | LMD GHOSTに用いる
| source | 最新のjustified (後述) されたと思うブロック | Casper FFGに用いる
| target | 現在のepochで最初にあると思うブロック | Casper FFGに用いる

### checkpoint, justified, finalizedの定義
- Ethereumでは各epochの最初のブロックを **"checkpoint"** と呼ぶ
  - slotが空の場合は直近のブロック
- 投票のsource, targetは、このcheckpoint部分を宣言の対象とする
- このとき、全stake量の2/3以上の投票を得たtargetを **"justified"** とみなす
- 新たにjustifiedブロックが生まれた場合、その前にjustifiedされたブロック以前の全ブロックは **"finalized"** とみなす
  - こうなると基本的に覆らない
  - 覆すには、全stake量の1/3以上のetherをpenaltyとして失うことが必要となる ("economic finality")
  - `なぜ？: 二重投票した場合には罰則としてstakeしたetherが没収されるから(後述)`
  - 2/3と2/3は、少なくとも1/3だけ重複する
- チェーンの分岐や空のslotが延々と続くなどの事態がなければ、checkpointは大体1.5epoch (9.6分) 後にfinalizedとなる


### LMD GHOSTについて
- epoch内で分岐した場合の「最も重いチェーン」は、各分岐の先端から遡って最も多くの投票 (beacon_block_root) を集めたチェーンとする
- このとき... ①投票は各バリデータのstake量に応じて重み付けされる (ただし32ETHが上限) ②投票数の計算は直近のjustifiedブロックからはじめる

### Casper FFGについて
- epochを跨いで分岐した場合の「最も重いチェーン」は、一番先にckeckpointがjustifiedになったチェーンとする
- 低い投票率や票の割れによってもし4epochの間にfinalizedが発生しなかった場合、投票していない or 少数派に投票しているバリデータのstakeを徐々に没収する (inactivity leak) ことで事後的にfinalizedにする仕様になっている 

### 報酬メカニズム
- ブロック提案者とブロック投票者に対してetherが報酬として新規発行される
  - Bitcoin Protocolには投票がないためブロック提案者 (マイニングノード) のみが対象でした
- 報酬 (および罰則) は、epochごとに計算・反映される
- 報酬額はバリデータ毎に異なるbase rewardを基本に計算される
  - base reward = 上限を32ETHとした自分のstake量 / (16*sqrt(総stake量))
  - つまり...自分のstake量が減ると後々貰える報酬は減る＆総stake量が増えても減る
  - Bitcoin Protocolの半減期的なイメージ
- base rewardを64として、各行為に対して以下の重み付けで報酬が発生する:

| 重み | 行為 | 備考 |
| ---- | ---- | ---- |
| 14 | Casper FFG 投票において「正しい」 source に投票した | 投票の方が重い
| 26 | そのslotにおける何番目のcommitteeに所属しているかCasper FFG 投票において「正しい」target に投票した | 投票の方が重い
| 14 | 先端だと思うブロックのヘッダーのハッシュLMD-GHOST 投票において「正しい」 beacon_block_root に投票した | 投票の方が重い
| 2 | comitteeに選ばれた際に、ブロックの検証作業を行った | 
| 8 | ブロック提案者に選ばれた際に、割り当てられたslotに新しいブロックを提案した | 

さらに追加報酬として、以下の要素が存在する:

**ブロック提案者**
- attestation reward・・・集約された宣言 (投票) 1つをブロックに含めるたびに 8/64 * base reward 貰える (現在のEthereumでは、ブロックには64~128個含めることが可能)
- slashing reward・・・バリデータの不正行為の証拠となるデータをブロックに含めるたびに 対象となったバリデータのstake量/512 貰える

**ブロック投票者**
- inclusion delay reward ・・・ 投票を行うたびに獲得出来る報酬。base reward分貰えるが、割り当てられたslotから遅れるたびに報酬額が半減していく (32slot進むと0)
  - 早く投票するように促している

### 罰則メカニズム　　   
**サボってしまった場合:**
- ブロック提案者もブロック投票者も、単に報酬機会を逃すだけ
- しかし先述のinactivity leakが発生した場合には、2/3の集票が成立するまで、投票しなかった or 少数派の選択肢に投票した  バリデータのstake量が減らされる

stake量の減少は、ブロックの提案・投票ノードに選ばれる確率が下がることを意味する。さらに、stakeが半分の16ETHを割った場合には自動的にバリデータの地位を喪失することになっている

【キャスレー：以前に32ETHで宝くじ1枚という例がありましたが、実際にサボった（or後述の不正をした）場合、一気にETHが減るのではなく徐々に減っていく理解？また、ETHはちょっとずつ減っていくようですが、以前に決まった金額（32ETH）でしか投入できないと理解したが、減った分だけ追加するというのはできたりするでしょうか？】

**不完全な内容を提出してしまった場合:**
- ブロック提案者は単に報酬機会を逃すだけ
- ブロック投票者はbeacon_block_rootが空の場合は単に報酬機会を逃すだけ
- しかしsource, targetが空の場合は、報酬として得られた分のetherがstakeから減らされる

**明確に悪意ある行為をした場合:**
- バリデータはネットワークから強制排除 (slashing) され、stakeしたetherも全て失う
  - ブロック提案者が、同じslotに対して2つの異なるブロックを提案する
  - ブロック投票者が、同じtargetを持つ異なる投票を重複して行う (二重投票)
  - ブロック投票者が、過去の source -> target 投票を囲むような投票を行う
    - 過去に source -> target の投票で、32 -> 64 という投票があるとする
    - 次のepochで 0 -> 96 などの投票を行うとslashing対象となる
    - Finalizedされたチェーンの歴史を覆すにはこうした投票が必ず必要になる (はず...)

Slashingは、バリデータが他のバリデータの不正行為を発見→
バリデータが不正行為の証拠データを作成してブロック提案者に投げる→
ブロック提案者がブロックに含める
という流れで行われる (証拠データの作成には報酬は発生しない)。
不正行為ありとみなされたバリデータは、ただちにstakeから1ETHが没収され、それから36日に渡ってstakeが減少→退出となる


### コンセンサスのまとめ　　       　　
- Ethereumは「**最も重いチェーン**」を正統とする
- 重いチェーンは **Gasperプロトコル** (LMD GHOST + Casper FFG) で定義されている
- どちらもブロックに含まれる投票 (attestation)を用いて「重いチェーン」を決める
- 報酬と罰則は、**ブロック提案者とブロック投票者の両方**が対象となる
- 報酬と罰則は、各バリデータのstake量と全体のstake量に応じて変動する。
*Gasperプロトコルは4年以上議論されてきたものの、現在も安全性や攻撃耐性などについて議論がなされています

*Ethereumのシステム全体におけるetherの総供給量は、
コンセンサスの報酬によって増え、コンセンサスの罰則とトランザクションの手数料で減る、という構造になっています。(現在は緩やかなデフレ)


# まとめ
以下のトランザクションのライフサイクルに沿って、Ethereumの構成要素がどのように連動しているかの詳細を確認した　

```
EOAは、トランザクション(Message Call or Contract Creation)を各ノードに伝搬する
各ノードは、受け取ったトランザクションを独立に検証する
各ノードは、問題が無いトランザクションのみを溜め、かつ他のノードに伝搬する
バリデータノードたちは、確率的にブロックの提案 or 投票ノードに選ばれる
投票ノードたちは、正統と考えるチェーンの先端にあるブロックを宣言する
提案ノードは、任意のトランザクションおよび宣言をブロックに格納する
提案ノードは、ブロック内のトランザクションを実行する
提案ノードは、ブロックを既存のチェーンに含まれるいずれかのブロックに繋ぐ
提案ノードは、完成したブロックを各ノードに伝搬する
各ノードは、受け取ったブロックに問題が無いかを独立に検証する
各ノードは、問題が無いブロックのみを自身のチェーンに反映する
バリデータノードたちは、最も重いチェーンを「正しい」状態遷移の記録とする
```

詳細は構造はここまで。最後にEthereumのガバナンスと課題をみてみよう。
