# Arbitrum について

- Arbitrum は Ethereum の L2 チェーンである

  - Ethereum で行うすべての操作を実行でき、トランザクションはより安価で高速になるのが売り
  - Ethereum との比較は[ここ](https://chainspect.app/compare/arbitrum-vs-ethereum)で確認できる

- Arbitrum には数種類のチェーンがある

  - Arbitrum One や Arbitrum Nova、Arbitrum Orbit など
  - それぞれ仕組みが少しずつ違うが、**今回は Arbitrum One を説明する**

- Arbitrum One は「Optimistic Rollup」を採用している

  - Rollup の中でも、L1 に送信されるデータが適切なルールに従っていると「楽観的に想定」したものを「Optimistic Rollup」と呼ぶ

    - つまり L1 に記録するデータがすべて正しいと仮定するということ
    - そのため L1 は L2 で処理された個々のトランザクションを検証しない
    - この性質によって、**L2 は絶対に間違ったトランザクションを L1 に記録しないような仕組みが必要**になる

- 以降「Arbitrum」は「Arbitrum One」を指す

# Rollup の基礎

- Rollup は、L1 で実行するべきトランザクション処理を L1 外で行うこと

  - そのため信頼性などに乏しく、 L2 にはトランザクションの正当性を確保するロジックが必要になる
  - ただし、L1 外で実行するため処理速度やガス代などで L1 よりも優れている

- Rollup における L1 の主な役割はトランザクションを実際に処理するのではなく、いわば台帳の役割となる

  - L1 に記録されることで、トランザクションは信頼できる（書き換え不能な）トランザクションになる
  - L2 は適切にトランザクションを処理したことを L1 に記録・公開することで信頼性を担保している

# L2 のトランザクションと L1 の関係性

- Rollup において L2 のトランザクションはまとめて（バッチ処理で） L1 に送信される

  - 複数のトランザクションを 1 回の L1 トランザクションで済ませるため、ガス代が安い
  - L2 で処理されたトランザクションデータを圧縮し、 L1 に送信・記録する
  - Arbitrum では通常数百個のトランザクションが含まれる

- 図にまとめると、Rollup の簡単な流れは以下のようになる

  ![Flow of Rollup](./img/rollup-flow.drawio.svg)

# トランザクションの構造

- Arbitrum は EVM 互換であり、EVM で行う基本的な操作をすべて行うことができる

  - しかし RPC メソッドのいくつかの挙動が変更されたり、トランザクションフィールドが追加されている
  - これは Arbitrum は EVM ではなく、AVM（Arbitrum Virtual Machine）を使用するからである
  - AVM の特徴は

# 主要なノード

- 主要なノードの役割・特徴を説明する

- ## シーケンサー

  - 特別に指定されたフルノードで、トランザクションの順序を制御するための限定的な権限が与えられている
  - 現在シーケンサーは Offchain Labs によって実行されている

- ## バリデーター

  - プロトコルの進行を監視するノード
  - これも現在は分散化されていない
  - 不正を指摘する（以降「チャレンジ」と呼ぶ）際に L1 に ETH をステークする必要がある
  - バリデーターには 4 種類の戦略がある

    - ### Defensive

      - RBlock に不正が見つかった場合にのみ、ステークを行いチャレンジを作成する

    - ### StakeLatest

      - 常に最新 RBlock に対してステークを行い（盲目的に正しいと賛同し）、見つかった不正にチャレンジを実行する

    - ### ResolveNodes

      - 作成された未検証の RBlock を検証し、見つかった不正にチャレンジを実行する

    - ### MakeNodes

      - 常に新しい RBlock を作成し続け、作成した RBlock が他ノードのものと異なった場合チャレンジに参加する
      - また、RBlock を作成する際は、必ず自身が作成した RBlock に対してステークをする必要がある

  - StakeLatest では「盲目的に正しいと賛同」と書いたが、上記すべてのノードにはデフォルトで、逸脱を検出するモードが実行されている

- 現在 Arbitrum はシーケンサー・バリデーターが善意を持って行動することを前提として動作している

  - 特にバリデーターに関しては、最低でも 1 人の正しいバリデーターが存在するのが必要条件になっている
  - これはチェーンをリリースするにあたって、ユーザーに安心して利用してもらうための苦肉の策である
  - いづれのノードも分散化が進められている段階である

# トランザクション処理の流れ

1. ユーザーがトランザクションをインボックスに送信
2. シーケンサーがトランザクションを順序付けし（無効なトランザクションは破棄）、ローカルでトランザクションを実行する
3. 十分なトランザクションがたまったら、シーケンサーはデータを圧縮し calldata として [Sequencer Inbox](https://etherscan.io/address/0x1c479675ad559DC151F6Ec7ed3FbF8ceE79582B6) に投稿（L1 コントラクト）
4. バリデーターは 3 で投稿されたトランザクションを実行する（通常 30 ～ 60 分ごと）
5. バリデーターはローカルでステートを更新（L2 ブロックを作成）する
6. バリデーターは L2 ブロックから「RBlock」を作成し、calldata として [Rollup](https://etherscan.io/address/0x5eF0D09d1E6204141B4d37530808eD19f60FBa35) に投稿（L1 コントラクト）
7. 6 で作成された RBlock は約 1 週間のチャレンジ期間が設けられ、バリデーターによって通常 30 ～ 60 分ごとにアサートされる
8. 異議が唱えられなければ RBlock は承認され、全てのアカウントがそれを L1 で確認できるようになる
9. 異議があればチャレンジが発生する

```
補足： L2 ブロックと RBlock の違い

L2 ブロックと RBlock は役割が少し違うため、構造にも少し違いがある。それぞれの構造は後述する。

L2 ブロックはチェーンの状態を保つためのブロック（L1 ブロックと役割は同じ）であり、
バリデータ ノードによって、シーケンスされたトランザクションの状態遷移関数を実行することによって生成される。

RBlock はプロトコルが管理および監視する、最新の状態のフィンガープリントとして機能する固有のブロックである。
それゆえ、L1 に投稿されるのは、追跡される RBlock である。
```

## ![Detail flow of transaction life](./img/rollup-detail.drawio.svg)

- 1 で、トランザクションは L1 に存在する [Delayed Inbox](https://etherscan.io/address/0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f) に直接送信することもできる

  - ブリッジ経由で ETH またはトークンを入金する場合に最もよく使用される
  - ここに入れられたトランザクションはシーケンサーによって、「先入れ先出し」方式で Sequencer Inbox に入れられる

- 2、3 それぞれのステップでレシートがひとつずつ返される

  |        | 名称                 | 説明                                                                                                        |
  | ------ | -------------------- | ----------------------------------------------------------------------------------------------------------- |
  | １回目 | ソフトファイナリティ | L1 に投稿する前に返される、シーケンサーからの実行結果。シーケンサーに悪意があれば間違っている可能性もある。 |
  | ２回目 | ハードファイナリティ | L1 でバッチデータが確認された後に返される、信頼できる実行結果。                                             |

  - ソフトファイナリティは、実行結果を即座にユーザーに返すために存在する

    - 順序付けされたトランザクションの実行結果は、状態関数によって決定論的に確定する
    - そのため、シーケンサーがそれを即座にチェックし結果を返している
    - しかし、バリデーターからの検証が終わっていないため、ハードファイナリティで返却される結果と乖離する場合がある
    - この段階で最終性を受け入れるかどうかは、シーケンサーを信頼しているかどうかに依存する

  - 逆にハードファイナリティは、正常なトランザクションとして処理が完了したことを表す

    - つまり、トランザクションが L1（Sequencer Inbox） で確認されたことを意味する
    - 完全にロールアップ処理が終わっていないのにもかかわらずこれが言える理由は[ここ](https://docs.arbitrum.io/how-arbitrum-works/tx-lifecycle#---finality-check-ethereum-equivalent-finality---)を参照

- 3 で L1 に投稿する理由はバリデーターが正しいデータを使用することを担保するため

  - Sequencer Inbox にデータを送れるのは基本的にはシーケンサーのみ
  - シーケンサーが 24 時間以上トランザクションを取り込まない場合は例外的に Delayed Inbox から誰でも追加できる
  - これはシーケンサーが機能停止してもチェーンが死なないようにするための策

- 3 で利用されるデータ圧縮アルゴリズムは「[brotli](https://github.com/google/brotli)」である

  - それぞれのトランザクションをバイト配列に圧縮し、それらをつなぎ合わせてバッチを作成している

## バリデーターによる検証の流れ

- 4 以降ではバリデーターがすべての処理を行うが、その詳細を説明する
