- [トランザクションとは何か](#トランザクションとは何か)
  - [従来の中央集権型取引との違い](#従来の中央集権型取引との違い)
- [トランザクションの登場人物](#トランザクションの登場人物)
  - [1. ブロックチェーン（ハッシュチェーン）](#1-ブロックチェーンハッシュチェーン)
    - [ハッシュについて](#ハッシュについて)
  - [2. P2P（Peer to Peer）](#2-p2ppeer-to-peer)
  - [3. ノード](#3-ノード)
    - [\*Merkle tree について](#merkle-treeについて)
  - [4. マイニング](#4-マイニング)
  - [5. PoW（Proof of Work）](#5-powproof-of-work)
    - [PoW の目的](#powの目的)
    - [PoW の流れ](#powの流れ)
    - [PoW の課題](#powの課題)
- [トランザクションのライフサイクル](#トランザクションのライフサイクル)
  - [トランザクションの検証について](#トランザクションの検証について)
  - [トランザクションプールについて](#トランザクションプールについて)
  - [Orphan transaction（オーファントランザクション）について](#orphan-transactionオーファントランザクションについて)
- [トランザクションのモデル](#トランザクションのモデル)
  - [UTXO モデル](#utxo-モデル)
  - [アカウントモデル（参考）](#アカウントモデル参考)
  - [比較](#比較)
  - [UTXO の保管について](#utxoの保管について)
- [Bitcoin Script](#bitcoin-script)
  - [特徴](#特徴)
  - [Bitcoin Script における処理の具体例](#bitcoin-scriptにおける処理の具体例)
- [UTXO の構造](#utxoの構造)
  - [vin の構造](#vinの構造)
  - [vout の構造](#voutの構造)
  - [locktime（nLockTime）について](#locktimenlocktimeについて)
    - [トランザクション単位のタイムロック](#トランザクション単位のタイムロック)
    - [UTXO 単位のタイムロック](#utxo単位のタイムロック)
- [トランザクション手数料](#トランザクション手数料)
- [トランザクションの種類](#トランザクションの種類)
  - [Pay-to-Public-Key-Hash (P2PKH)](#pay-to-public-key-hash-p2pkh)
  - [Pay-to-Public-Key](#pay-to-public-key)
  - [Multi-Signature](#multi-signature)
  - [データアウトプット（OP_RETURN）](#データアウトプットop_return)
  - [Pay-to-Script-Hash (P2SH)](#pay-to-script-hash-p2sh)
- [Coinbase トランザクション](#coinbaseトランザクション)
  - [Coinbase トランザクションの vin について](#coinbaseトランザクションのvinについて)
  - [Coinbase トランザクションの承認について](#coinbaseトランザクションの承認について)
- [\*SegWit（Segregate Witness）](#segwitsegregate-witness)
  - [SegWit の導入理由について](#segwitの導入理由について)
  - [ブロックウェイト（Block Weight）](#ブロックウェイトblock-weight)
  - [ブロックサイズについて](#ブロックサイズについて)
  - [データ構造について](#データ構造について)
  - [トランザクション方式について](#トランザクション方式について)
- [まとめ](#まとめ)

# トランザクションとは何か

- **トランザクション** とは、**暗号資産所有者が使用権利を他の人に渡す、すなわち送金すること**

```
Bitcoin(暗号資産)は分散型コミュニティによって管理される。
Bitcoinを所有したり、その権利を譲渡するためにはコミュニティ全体の承認を受ける必要がある。
そのため、利用者はトランザクションと呼ばれるデータをコミュニティに検証・承認してもらう。
この過程において、取引が正常に行われているかを確認する。
```

## 従来の中央集権型取引との違い

```
従来(Web2)における取引では、中央管理者が通貨の偽造や二重支払などの詳細をチェックしていたが、
Bitcoin(Web3)においてはすべてがプログラムで処理されるようになった。（PoWの節を参照のこと）
これによって取引の透明性やセキュリティ面が担保されるようになった。
```

# トランザクションの登場人物

- トランザクションを理解するにあたって必要な知識を最初にまとめた
- 特にトランザクションと切り離せない内容であるマイニングについてはよく理解してほしい

## 1. ブロックチェーン

- **ブロックチェーン** とは、**トランザクション情報をまとめた「ブロック」をハッシュ値に従ってつないだもの**

  - ハッシュ値によってすべてが連結されているため、１つのブロックを改ざんするためにはその後のすべてのブロックも改ざんする必要がある
  - これによって実質的に改ざん不可能の性質を獲得している

【キャスレー：不正データの承認や改ざんのリスクを回避しノードによる承認や情報管理のためにBitcoinではブロックチェーンを採用していると理解しているがあっているか。どうしてBitcoinではブロックチェーン技術が採用されているのかなどをまとめ等で記載があるとありがたい。】


- Bitcoin におけるブロックは以下の要素で構成される

  | 項目                       | 役割                                                                                         |
  | -------------------------- | -------------------------------------------------------------------------------------------- |
  | ブロックヘッダー（Header） | ブロックの整合性を保つための情報やマイニングに使われる情報、トランザクションの要約を提示する |
  | ブロック本体（Body）       | トランザクションのデータを保持する                                                           |
  | ブロックのサイズ           | ブロックの容量を示す                                                                         |
  | トランザクションの個数     | トランザクションの数を示す                                                                   |

- \*特にブロックヘッダーは以下の構成になっている

  | 項目                 | 役割                                                                           |
  | -------------------- | ------------------------------------------------------------------------------ |
  | ハッシュポインタ     | 直前のブロックのハッシュを示しチェーン状を保つ（連結されていることを担保する） |
  | ナンス （Nonce）     | マイニングの際に利用される１度だけ使われる数（使い捨ての数）                   |
  | Merkle root          | Merkle tree の root 値（トランザクション内容の要約だと理解してよい）           |
  | バージョン           | プロトコルのバージョン番号                                                     |
  | タイムスタンプ       | ブロックのおおよその作成時間（Unix timestamp 形式）                            |
  | 難易度（Difficulty） | マイニング時に使用される難易度                                                 |

  `注：Merkle treeについてはノードの項目を参照のこと。`

- 2024 年 3 月現在では Bitcoin の１ブロックは１ MB が上限となっている

  - 初期では最大 36MB の取引を含めることができていたが、2010 年に縮小された
  - Bitcoin のブロック容量については様々な議論が起こっている
  - 近年では Bitcoin の利用者も増え、上限に達することも多いことから容量拡大を求める声もある（スケーラビリティ問題）
  - 一方でブロックサイズの拡大は、Full node の負担が大きくなったり、DoS などの攻撃リスクを上昇させる可能性もある
  - ここからハードフォークや「セグウィット（Segregated Witness：SegWit）」が始まった

- 現在 SegWit の採用率は上がっており、ブロックサイズは 4 MB に拡大されたと解釈する人もいる
  - SegWit については[SegWit（Segregate Witness）](#segwitsegregate-witness)を参照のこと

---

### ハッシュについて

- ハッシュ関数の性質は簡単に言うと、出力された値に対して、入力値が特定困難な関数である
- ここでは Bitcoin でよく使用される暗号学的ハッシュ関数「SHA-256」を例に説明する．出力値は 256 ビットの値である

以下、ハッシュ関数を $H$， 入力 $x$ に対する出力を $H(x)$ とする

```
例：
      h = H(1) = 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b があったときに、
      hの値から x = 1 を求めるのは困難であるということである。
```

- またハッシュ関数の特徴として、同じ入力値には必ず同じ出力値をとる
- これにより、入力値 $x$ が一致しているかどうかを確認するためには $H$ に $x$ を入力するだけで簡単にわかる
- これらの性質によって、ブロックチェーンは改ざん困難かつ、第三者の検証（PoW）が可能になっている

#### \*暗号学的ハッシュ関数

- 暗号学的ハッシュ関数は、数学的なハッシュ関数が満たす条件に加え以下の条件を満たすものである

1. ハッシュ値から入力値が特定困難であること（原像計算困難性）

   - これに関しては上述したとおりである

2. ある値のハッシュ値と同じハッシュ値を得るような入力値を見つけるのが困難であること（第 2 原像計算困難性，弱衝突耐性）
   - すなわち、x から得られた$H(x)$に対して， $H(x) = H(y)$ かつ $x \neq y$ となるような $y$ を見つけるのが困難であるということである

- 「困難」というのは、理論上は可能だが実現性がとても低いという意味である

3. 同じハッシュ値となる入力値のペアを見つけるのが困難であること（強衝突耐性）
   - 「2」と似ているが，これはハッシュ値は任意に選んでも良く，$H(x)=H(y)$となる$x \neq y$のペアを見つけるのが困難であるということ．

---

## 2. P2P（Peer to Peer）

- **P2P**とは、**サーバーなどの中心的な機関や装置を持たず、末端の端末（ピア）同士が互いに信頼し合うことで成立するネットワークのこと**
- Bitcoin では非構造化ネットワーク (Unstructured P2P Network) が利用されている

  - \*Bitcoin ではプロトコルとして Gossip や Diffusion を使用している

- 冗長性がありデータ処理を分散して素早く実行できる一方で、悪意あるユーザーを排除しにくい

## 3. ノード

- **ノード**とは、**Bitcoin ソフトウェアを実行するコンピューターのこと**
- ウォレットなどもノードに分類される
- Bitcoin におけるノードには以下の種類がある

  |                  | 検証の対象             | データ容量                  |
  | ---------------- | ---------------------- | --------------------------- |
  | Full node        | チェーン全体を検証     | 約 550GB 程度 (2024/2 時点) |
  | Miner node       | 複数のトランザクション | Full node と同じ            |
  | Light node (SPV) | ブロックヘッダーのみ   | Full node の 1 / 1000 程度  |

  `注：すべてのnodeのデータ容量はブロック数が増えるごとに日々増加している。`

---

- ### Full node

  - チェーン全体の完全なコピーをホストし同期する（クライアントが独立してチェーンを検証できる）
  - マイナーが作成したブロックの検証を行う（２重支払いのチェックなど）
  - イメージとしては、ネットワークのセキュリティと整合性の維持を目的とすると考えて構わない
  - Light node（SPV node）に対して信頼されたチェーンを提供する
  - Light node（SPV node）と比べ、セキュリティやプライバシーの観点で優れている
  - Pruned node という Full node のストレージ要件を削減するためにできたノードも存在する（Bitcoin Core）[参考](https://thebitcoinmanual.com/behind-btc/nodes/pruned-node/)
  - Pruned node は Light node（SPV node）にブロックを提供できない

- ### Miner node

  - ネットワーク上にブロードキャストされたトランザクションをマイニングを通じて検証する
  - Full node はブロックの検証を行う一方で、Miner node は新たなブロックを作成する
  - 運用に多大な計算・ストレージリソースを割く必要がある

  ```
  Full nodeとMiner nodeに関しては、ノードとして同一種類であるという見解も多々存在する。
  それらの見解は、どちらもネットワークを健全に維持するためのノードであるという理由からである。
  今回大別したのは、「マイナー」がどのような存在かをイメージしやすくするためである。
  多くの場合，Miner nodeは，自身でブロックチェーンの検証も行えるFull nodeでもある．
  ```

- ### Light node (SPV: Simplified Payment Verification)
  - Full node とちがい，ブロックデータ全てではなく，ブロックヘッダーのみのチェーンを保持する
    - ボディやその他の情報は取得せず、ヘッダ列のみを取得する
    - ヘッダだけでもジェネシスブロックからチェーンの検証ができるから
  - ウォレットで使用される
  <!-- todo マルチビットとは？ => RE: マルチビットは人気だったウォレットだったのですが、開発中止になったらしいので削除します -->
  - 必要なトランザクションなどのデータは他の Full node から適宜取得する
  - ノードに関係のある情報しか取得しないため軽量である一方で、閲覧できる情報に制限がある
  - Full node からデータを取得する際に、データ不整合が起こるリスクがある
  - \*ノードのハッシュをツリー化した、Merkle tree によって検証可能になっている

---

### \*Merkle tree について

- Merkle tree とは、多数のデータをハッシュ化して階層状にしたもの

  - Bitcoin ではトランザクションをマークルツリーで管理し、ブロック内に含まれるトランザクション全体を要約する
  - 特にブロックチェーン発祥の技術ではない

- 各要素のダブルハッシュを取り、隣のハッシュとつなげてまたダブルハッシュを取り、と繰り返していく

  - ダブルハッシュとは SHA256 を 2 回繰り返す処理

- 最下層に要素を並べて，ハッシュを計算したものを一段上の層に並べ，と下から上に，山のように表現される構造である

  - 最上位の要素を特に「Merkle root」と呼ぶ
  - 一番下に並べてあるもともとの値のハッシュ値を「葉」と呼ぶ
  - Merkle root を含め各要素は常に 32 バイトになる
  - \*葉の数が$2^n$でない時は、１番最後の要素が複製され使用される
  - 葉が，ブロック内に含まれる各トランザクションのダブルハッシュ値で構成される
    ![Merkle treeの構造](./img/merkletree.drawio.svg)

- どこか１つでも「葉」が書き換えられると、Merkle root の値が変化する

  - したがって、トランザクションが書き換えられていないかの確認に使用される（ブロックヘッダーに保持）

- Merkle root が与えられたときに，表現される Markle Tree 内に特定の「葉」が含まれるかの検証が効率よく行える
  - \*検証に必要な要素の数は葉の数（ブロック内のトランザクション数） $N$ に対して $log_2(N)$ 個
  - 上記図を例にとり、 $H_A$ が含まれるかを確認するとする
  - 必要な要素は $H_B$ と $H_{CD}$ のみである
  - なぜならば、それら２つがあれば $H_A$ と合わせて Merkle root を求められるからである
  - $H_B$ と $H_{CD}$ のように、葉$H_A$に対して検証に必要な要素を「Merkle Proof」と呼ぶ

---

## 4. マイニング

- **マイニング**とは、**トランザクションを検証・承認しブロックに情報を保存すること**
- マイニングが行われることによって Bitcoin が新規発行される（発行上限は 2100 万枚と決まっている）
- これを実行するノードは「マイナー（Miner）」と呼ばれ、マイニングの報酬として Bitcoin（暗号資産）を享受する

  - マイニングによって Bitcoin を受け取れるのは、最初にハッシュによって構成される計算量を要する問題を解いた者だけである
  - これによりマイナー同士の競争が起こる

- Bitcoin には半減期という仕組みがあり、マイニングによって得られるビットコインが半分に減少するタイミングがある

  - 半減期はおよそ４年に１回程度で起こっている（21 万ブロックごと）
  - マイニング報酬の遷移は以下の通り

    | 半減期の回数（実施年）        | マイニング報酬 |
    | ----------------------------- | -------------- |
    | 初期                          | 50BTC          |
    | 1 回目（2012 年）             | 25BTC          |
    | 2 回目（2016 年）             | 12.5BTC        |
    | 3 回目（2020 年）             | 6.25BTC        |
    | 4 回目（2024 年と予想される） | 3.125BTC       |

- マイニング作業は、コンセンサスアルゴリズムに PoW（Proof of Work）を採用しているブロックチェーンで行われる

  - 一方で、PoS（Proof of Stake）や DPoS（Delegated Proof of Stake）といったアルゴリズムを用いるチェーンでは「ステーキング（Staking）」が行われる
  - Bitcoin や Litecoin などが PoW を、Ethereum や Binance Coin などが PoS を採用している

- マイニングの具体的な流れについては次項（PoW の流れ）を参照のこと

## 5. PoW（Proof of Work）

### PoW の目的

- PoW の目的は、ノード同士が相互に信頼できない環境（P2P）において、すべてのノード間で合意、つまり相互に信頼を得ることにある
- 直接的に言うのであれば、あるノードのマイニング結果が本当に正しいものなのかを、ノード同士で確認しあうのである
- PoW による検証・承認を経て、新たなブロックが作成されチェーンに追加される

```
PoWは一定の計算量を投じたブロックのみOKとすると定めたルールであり、そのルールに合意するかどうかはビットコインに参加する個々人の判断に委ねられる。
結果的に残った人はそのルールを受け入れているため、コンセンサスが得られている。
```

### PoW の流れ

- PoW における作業は、計算リソースを必要とする問題を解くことである

  - 多量の計算リソースを要求することによってブロックの改ざんを実質的に不可能にするため

- マイニング結果が、承認を行うノードに承認されるとブロックが新規追加される
- 具体的な流れは以下の通り

```
1. マイナーがトランザクションプールからいくつかのトランザクションを選択し、新たなブロックを作成する
2. マイナーが問題を解き、ブロックを提示する
3. 他のノードが、検証・承認を行った上で自身が持つブロックチェーンに追加する
```

- この PoW を含めた一連の流れを「マイニング」と呼んでいる

### PoW の課題

- #### 消費電力が多い

  - マイニングを行うためには多くの計算リソースを要求される
  - マイニングに成功した最初の 1 人以外は利益（Bitcoin）を得ることができないため競争が起こる
  - マイナーは競争に勝つためにより大規模なマシンを用意しマイニングを行うため、消費電力が増える
  - 消費電力は約 20.45 GW と推定されているデータもある（https://ccaf.io/cbnsi/cbeci）

<!-- - #### スケーラビリティ問題

  - Bitcoin では、約 10 分に１回新しいブロックが生成されるようになっている（「難易度（Difficulty）」によって自動調整される）
  - しかし需要がどんどん増える中で、10 分という時間がボトルネックになってきた
  - トランザクションを処理しきれず、「詰まり」が発生するようになった
  - todo スケーラビリティはPoWと直接関係はないためコメントアウト-->

- #### 51%攻撃

  - とある組織が複数のノードを運営しマイニングを行うことで、ノード全体の 51%など非常に多くの計算パワーを得たとする
  - このときその組織は 高い確率でマイニングに成功する
  - さらに，2 個分以上続けてブロック生成に世界でいち早くできる可能性もある．
  - これによって、その組織は一度生成されたブロックを意図的になかったことにし別のブロックを先端として採用することが可能になる
    - もともとのブロックに含まれていたトランザクションと矛盾するトランザクションをあとに生成したブロックに含むなど，2 重支払いを可能にしてします
  - このような脆弱性があるが、現状大量のマイニングノードが存在するので全体に影響がでるくらいの多くの計算力を持つのは困難
  - 注意：特に「51%」の計算パワーがなくとも確率的には上記のような攻撃は可能．慣例的に「51%攻撃」と呼ばれている

# トランザクションのライフサイクル

- トランザクションのライフサイクルは以下の通り（[PoW の流れ](#pow-の流れ)も参照のこと）

### 1. 組成

- 送金先のアドレスを指定する
- Bitcoin を送る人がデジタル署名を付与する

### 2. ブロードキャスト

- トランザクションをネットワークに送信
- 送信されたトランザクションは各ノードに伝搬される

### 3. マイニング

- マイナーによってブロックに含むトランザクションリストが選ばれる
- マイナーがマイニングを行い，新たに作成したブロックをブロードキャストする

### 4. 記録

- マイナーから提出されたブロックを各ノードが検証する
- 検証に成功したブロックはブロックチェーンに繋がれる

## トランザクションの検証について

- トランザクションが検証される内容について、大まかには以下の通り

  1. 資金の不足がないか
  2. トランザクション形式は正しいか
  3. 二重支払ではないか
  4. 署名は有効か
  5. 手数料は適切か

- この他にも、通信状況、トランザクションを送信するソフトウェアなどが原因で検証や伝搬に失敗することもある

## トランザクションプールについて

- トランザクションプールとは、ブロックに入る候補となるトランザクションをためておくプールのこと

  - 伝搬されたトランザクションは、まず検証される
  - 検証が通った有効なトランザクションはトランザクションプールに入れられる
  - マイナーはこのプールの中からトランザクションを選択し、ブロックに組み込む

- このプールは各ノードが保有するもので，各々のノードのトランザクションプールは異なる

## Orphan transaction（オーファントランザクション）について

- Orphan transaction とは、親子関係が逆転してしまったトランザクションのことである

  - トランザクションは必ずしも送信順に伝搬されるわけではない（ネットワーク間の伝達スピードの関係などが原因）
  - そのため、送金の順番が前後した状態でノードに届いてしまうことがある
  - この場合、トランザクションは「オーファントランザクションプール」に入れられ、親を待機する
  - 親が届くと、親を待機していたすべてのトランザクションが取り出される

- オーファントランザクションプールには上限（MAX_ORPHAN_TRANSACTIONS）がある

  - これはノードからの DOS 攻撃を防ぐため
  - これを超えた場合、ランダムなトランザクションが破棄される

- 説明は省くが、オーファントランザクションと似たものに「Orphan block（オーファンブロック）」もある
  - [ここ](https://academy.binance.com/ja/glossary/orphan-block)を参照のこと

# トランザクションのモデル

- ビットコインは UTXO モデルと呼ばれるモデルが採用されている
  - また、参考までに Ethereum はアカウントモデルと呼ばれるモデルで構築されている

```
注：以降、「インプット」「アウトプット」という単語が出てくるが、それぞれ「出金元」「送金先（または自身の口座）」
    というような理解で一旦読み進めて構わない。正確には「UTXOの構造」で登場する、「vin」「vout」に該当する。
```

- ## UTXO モデル
- **UTXO（unspent transaction output）** とは、**トランザクションアウトプットのうちまだ使用されていないもの**
- UTXO モデルにおける残高は、未使用のビットコインの固まりである

  - 自分から誰かに送金をすることをイメージすると，自分の残高があってそこから誰かに送金をする，と考えがちだがそうではない．（それはアカウントモデル）
  - 誰かが自分に ◯BTC 送金したトランザクションがあり，その受け取った ◯BTC を起点に他の人に送金できる，というモデルが UTXO モデル．
  - イメージとしては、普段使うお札のようにある程度の金額が固まっている状態である
    - 例えば A さんから B さんに 10BTC 送金した場合，B さんはその受け取った 10BTC を起点に他の人に送金できる．
  - UTXO モデルにおいて暗号資産を使用する場合は「おつり」が返ってくることがある
    - 上記の例で B さんが C さんに 2BTC 送金した場合は，全部で 10BTC の固まりのうち 2BTC は C さんに，残りの 8BTC は自分自身への送金（おつり）となる
  - また、普段複数のお札を使って支払いができるように、UTXO においても複数のアウトプットを使って支払いができる（[後述](#vin-の構造)する）

- １度使用された UTXO は 2 度と使用することができない

  - これによって 2 重支払いを防いでいる

- 残高を求めるには UTXO のアウトプットを合計する必要がある

  - ブロックチェーン上のすべてのトランザクションが未使用かどうかをチェックし UTXO を抽出し，アドレスごとの UTXO すべての金額を足し合わせるとそのアドレスの残高が求められる
  - 残高を求めるためにその都度合計しないと求まらないという観点では扱いずらい

- ## アカウントモデル（参考）

  - 銀行口座のように、アカウントの残高を直接データとして記録する
  - したがって支払う際は、引き出し元の残高を減らし、送金先の残高を増やすだけ
  - 要するに銀行の振込と仕組みは同じ

- ## 比較

  |              | UTXO モデル | アカウントモデル |
  | ------------ | :---------: | :--------------: |
  | データサイズ |             |        ○         |
  | 同時処理     |      ○      |                  |
  | シンプルさ   |             |        ○         |

  - アカウントモデルには複雑なインプットが必要ないのでトランザクションデータが比較的小さい

    - UTXO モデルでは複数の UTXO をインプットにとる可能性があるが、アカウントモデルでは出金元はアカウントなので１つ

  - UTXO モデルは複数のアウトプットから通貨を集めて支払うため、同時処理が比較的しやすい

    - 支払いに使用するアウトプットがすべて独立していれば、同時処理が可能
    - 逆にアカウントモデルでは、同時処理する取引において、該当アカウントはもちろん関連するアカウントの残高を相互に影響が受けないか確認する必要がある

  - アカウントモデルの方がシンプルな処理を行うので、機械処理はアカウントモデルの方が向いている

    - スマートコントラクトでアカウントモデルの方が利用されている一因である

## UTXO の保管について

- UTXO モデルではアカウントモデルと異なり各アドレスの残高をチェーンで管理しない

  - 毎回ジェネシスブロックからすべてのブロックをチェックすることで UTXO を抽出することは可能だが、計算コストがかかる
  - そのため UTXO は Bitcoin Core などビットコインクライアントの機能として，ブロックチェーンの外側で独自に構築した DB で管理される
  - この特別な DB を「UTXO セット」と呼ぶ

- UTXO セットは新たなブロックが作成されるごとに更新される

  - ウォレットはその情報をもとに残高を算出する
  - また、暗号資産の総流通量もこれを基に算出される

- UTXO セット のデータ構造は、Bitcoin のパフォーマンスとストレージ要件に直接影響を及ぼす
  - なぜならば、これらのデータはオンチェーンでの処理と切り離せないからである
  - また、Full node が検証・マイニングを行うため、Full node の処理性能にかかわる部分が Bitcoin のパフォーマンスにも影響を及ぼす
  - したがって、UTXO セットのデータ構造を最適化することが重要視される

# Bitcoin Script

- Unlocking / Locking Script に使用される Bitcoin 上で実行可能なスクリプト言語のこと
  - Unlocking / Locking Script とは UTXO に対してかかっている鍵を開ける方法，また鍵のかけ方である
  - 多くの場合は，電子署名とその検証で実現している．
  - つまり，普段送金の際に「秘密鍵を持っていないと送金できない」という処理を記述しているのは，この Bitcoin script．

```
注： 以降「pop」「push」といった単語が出てくるが、それぞれスタックというデータのいれものに対して、
    「1番上のものを取り出す」「1番上に要素を追加する」という意味である。
```

## 特徴

### 1. スタックベースの処理

- データ、オペコードはスタック：LIFO（後入れ先出し）で管理される

  - 箱の中に最後に入れたものを，取り出すときは最初に取り出される
  - \*スタック上のバイトベクトルの長さの上限は 520 バイト

- 左から右へ処理する

### 2. チューリング不完全

- 簡単に言うと、特定の役割に特化しているということ

  - 逆にチューリング完全は、だいたいどんな計算でもできる、というような意味
  - Bitcoin Script は一般的なプログラミング言語で実現できるような処理の多くは実現できない

- また、ループ、再帰、自身で強制終了しない他， goto 変数をサポートしない．ステートの保持もできない．
  - これが任意の実行を走らせにくくしている

### 3. オペコードを使用する

- 「OP_ADD」や「OP_EQUAL」のような、処理を指示する文字列をオペコードという
  - \*整数や論理値をスタックから取り出すオペコードは 4 バイト以下

### 4. ステートレス

- これにより、どんなシステム上でも自己完結的な実行ができる
  - この結果の予測可能性は Bitcoin システムの本質的な利点である
- しかしながら，データを「記憶」することはできず，1 回 1 回で処理が完結する必要がある

## Bitcoin Script における処理の具体例

- 以下のコードが与えられたときの処理を考える

  `2 3 OP_ADD 5 OP_EQUAL`

- オペコードの役割は次の通り

  | 名称     | 役割                                                                                                                          |
  | -------- | ----------------------------------------------------------------------------------------------------------------------------- |
  | OP_ADD   | スタックから 2 つのデータを pop して、それらを加算した結果をスタックに push する                                              |
  | OP_EQUAL | スタックから 2 つのデータを pop して、それらが等しければ True(数値の 1)、等しくなければ False(数値の 0)をスタックに push する |

- 実際の処理手順

  | 処理                                                                                                   | 結果               |
  | ------------------------------------------------------------------------------------------------------ | ------------------ |
  | 1. データ「2」をスタックに pop する                                                                    | `2`                |
  | 2. 次のデータ「3」をスタックに pop する                                                                | `2 3`              |
  | 3. 次のデータオペコード OP_ADD に従って、左から２つデータを取り、足す                                  | `5`                |
  | 4. 次のデータ「5」をスタックに pop する                                                                | `5 5`              |
  | 5. 次のデータオペコード OP_EQUAL に従って、左から２つデータを取り比べた結果を入れる（5=5 なので True） | True               |
  | 6. 次のデータがないので終了                                                                            | 実行結果は**True** |

- 参考画像

<!-- todo 画像をスタックの一般的な上から積み上げていく形で書き直す -->

![Bitcoin scriptの処理プロセス](./img/bitcoin-script.drawio.svg)

- Unlocking / Locking Script は Bitcoin Script で記述される
  - 実行結果が True でない場合のトランザクションは検証に失敗し，ブロックには取り込まれない．

# トランザクション の構造

<!-- TODO Txのデータ構造と何バイト目になんのデータが入っているのか一覧に作り直す．実質的に含まれる情報と，本当に入っている情報が混在していると混乱するため．

ウィットネスデータありの場合の txid はないってこと？ => RE: これに関しては意味がよく分かりません。txid は非 SegWit であればトランザクション全体のハッシュ値ですが、SegWit を使用する場合は Witness を除いた部分から作成されるハッシュ値のことです。したがって、わざわざ txid, hash と別れた項目になっています。なので非 SegWit であれば txid と hash は一致するはずです。以下の表の説明もその意味が伝わるように書いたつもりだったのですが、伝わっていなかったようなので変更します。

size は Tx 中のフィールドとして存在する？測ればよいだけな気がする．=> RE: トランザクションには含まれないと思います。ただ私が以下のように表を作った意図としては、例として提示されるデータ（json）に、説明されない項目がないほうが良いと考えたからです。もちろんデコード後の値をこちら側で取捨することは可能ですが、そちらの方が都合がいいでしょうか？
-->

- トランザクションのデータ構造は以下の図の通り

![トランザクションのデータ構造](./img/transaction-structure.drawio.svg)

- トランザクション(略：tx)は以下の要素で構成される
- これは，Tx を表現するデータ構造でないことに注意．データ内に含まれる，もしくはそこから抽出（デコード）できるデータを並べたもの．

| 名称                  | 説明                                                                                                                        |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| txid                  | トランザクションの一意の識別子（ウィットネスデータを除いて計算する）                                                        |
| \*hash                | ウィットネスデータを含めたトランザクションのハッシュ値．SegWit においてトランザクションの完全性を保証するための値           |
| size                  | トランザクションのデータの大きさ． ブロックを１ MB に収めるためにマイナーが参照するための値                                 |
| \*vsize               | SegWit の重みを低くしたときの仮想サイズ．SegWit 導入時のデータサイズを公平に計算するための値                                |
| \*weight              | $nonWitnessDataSize*4+WitnessDataSize$で表せるブロックウェイト．SegWit 導入時のアウトプットに係るコストを最適化するための値 |
| version （nVersion）  | トランザクションのタイプを指定する整数値．適用されるフォーマットやルールセットの互換性を保つための値                        |
| locktime（nLockTime） | アウトプットをいつから使用可能にするかを指定するための値 ．UNIX タイムスタンプまたはブロック高で表現される．                |
| vin                   | 入力されるトランザクションの配列．どのトランザクションのどのアウトプットからの支払いを実行するのかを指定する                |
| vout                  | 出力されるトランザクションの配列．アドレスやスクリプトを指定し、新たなアウトプットを作成する                                |

`補足：txidはデータをダブルハッシュ（SHA256を2回）した値で，データ中には含まれていない`

- 実データの具体例を示す
<!-- todo バイト列表記をここに記す．デコードデータは実データではなく，実データを人間が読みやすいようにJSONで表現したもの．
↓のTxに対してフルノードで検索してみる．blockchain.comからはローデータが取得できない様子．
 -->

```
0100000001186f9f998a5aa6f048e51dd8419a14d8a0f1a8a2836dd734d2804fe65fa35779000000008b483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adfffffffff0260e31600000000001976a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788acd0ef8000000000001976a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac00000000
```

- デコードデータの具体例を示す
<!-- todo 以下に続く説明でこの具体例に触れながら説明したい． -->

```json
{
  "txid": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
  "hash": "0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2",
  "size": 258,
  "vsize": 258,
  "weight": 1032,
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig": {
        "asm": "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
        "hex": "483045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301410484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf"
      },
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.015,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG",
        "desc": "addr(1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA)#ykrtxd0a",
        "hex": "76a914ab68025513c3dbd2f7b92a94e0581f5d50f654e788ac",
        "address": "1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA",
        "type": "pubkeyhash"
      }
    },
    {
      "value": 0.0845,
      "n": 1,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
        "desc": "addr(1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK)#e6ft626y",
        "hex": "76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
        "address": "1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK",
        "type": "pubkeyhash"
      }
    }
  ]
}
```

（「Mastering Bitcoin. O’Reilly Online Learning」(https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch02.html)より引用）

- 上記のトランザクションでは、以下のような操作をしている（以下のブロックエクスプローラーから実データにアクセス可能）

  参考：(https://www.blockchain.com/explorer/transactions/btc/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2)

  - 自分のアドレス`1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK`（残高 0.1BTC）から

    - 0.015BTC をアドレス`1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA`に送信
    - 0.0845 をアドレス`1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK`に送信（自分に戻した）

  - 残りの 0.0005BTC はトランザクション手数料になった
  - タイムロックは付与しない
  - トランザクション方式は P2PKH（[後述](#pay-to-public-key-hash-p2pkh)）

## vin の中身

- 資金の引き出し元を示す配列が vin である

  - 複数の UTXO を持つこともある

- vin は以下の要素で構成される

  - \*txinwitness は SegWit 使用時のみ含まれる項目である

  | 名称                          | 説明                                                                                                                                                                                       |
  | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
  | txid                          | インプットに指定する UTXO を含む Tx の ID                                                                                                                                                  |
  | vout                          | 使用する UTXO が txid で指定する Tx 中に含まれているアウトプットのうち何番目なのかを示すインデックス．txid で指定したトランザクションにある アウトプットのうち、どれを使用しているかを示す |
  | scriptSig（Unlocking Script） | トランザクションのロックを解除するための情報                                                                                                                                               |
  | sequence（nSequence）         | 現在は相対ロックタイムを示す． 前項[nSequence](#nsequence)を参照のこと                                                                                                                     |
  | \*txinwitness（Witness Data） | インプットごとの証人データを格納した配列． SegWit 導入時に署名データなどを保持する                                                                                                         |

### scriptSig（Unlocking Script）について

- scriptSig は、インプットとして指定している UTXO の scriptPubKey (Locking Script)を解除するための情報が入っている

  - トランザクションの形式によって、scriptSig の中身は変わる
  - 詳細は各トランザクション形式の説明を参照のこと

- 「asm」はアセンブリ形式で表現されている

  - \*vin では以下のように分けられる

    - ECDSA 署名を DER エンコードしたもの　`3045022100884d142d86652a3f47ba4746ec ... ad530a863ea8f53982c09db8f6e3813`
    - SIGHASH フラグ（SIGHASH については[ここ](https://wiki.bitcoinsv.io/index.php/SIGHASH_flags)を参照のこと）　`[ALL]`
    - vin の公開鍵　`0484ecc0d46f1918b30928fa0 ... ee41c04f4938de5cc17b4a10fa336a8d752adf`

  - vout では Bitcoin Script になっている（[後述](#bitcoin-script)）

  - 「hex」は「asm」の 16 進数表現

    <!-- todo asmデータってアセンブリ形式で表現されているデータではなかったの？以下のデータは上記のJSON中でどこに記載されている？もし省略しているのであれば，以下のデータがどこに表現されているかわかるように省略すべきではない
    => RE: 省略したデータに関しては修正しました。「asmデータってアセンブリ形式で表現されているデータではなかったの？」についてはよく理解できなかったので、「asm」の説明を詳細にしました。これらはデバッグに使用するための値なので＊を付しておきます
     -->

  - 今回は P2PKH のアンロッキングスクリプトが表現されているが、トランザクションの種類によって対応する Unlocking Script が表現されることに注意
    - P2PKH の場合，正しい Unlocking Script 作成には秘密鍵が必要である
    - 不正な Unlocking Script のトランザクションは、検証に失敗するため伝搬されない

## vout の構造

- 資金の送信先を示す配列が vout である

  - vout はそれぞれが新しく作成される UTXO である
  - 「おつり」などの余剰分の手数料もいずれかの UTXO に含まれる

- vout は以下の要素で構成される

  | 名称                           | 説明                                                                                    |
  | ------------------------------ | --------------------------------------------------------------------------------------- |
  | value                          | アドレスに送られる Bitcoin の量． 単位は「satoshi」である 1 satoshi ＝ 0.00000001BTC ） |
  | n                              | UTXO のインデックス，すなわち vin で UTXO を指定する際に使用するインデックス            |
  | scriptPubKey（Locking Script） | トランザクションのロックを解除するための情報．送金先アドレス情報を含む．                |

### scriptPubKey（Locking Script）について

- scriptPubKey は、vout を使用できる人を制限するための条件を指定している

  - トランザクションの形式によって、scriptPubKey の中身は変わる
  - 詳細は各トランザクション形式の説明を参照のこと

- 構成要素はおおよそ以下の通り（以下と異なる可能性もある）
  <!-- TODO 以下は様々な比較不可能な情報が混在している．Txの固定長表現のLocking Scriptからどのような情報が抽出されるか，その情報を要記述．
  そしてそれに含まれていない補足の情報はそのことが分かるように記述が必要．
  Locking ScriptであるならばそれはBitcoin Scriptで表現されるもの以外の情報は入っていないはず．
  => RE: デコーダーで表記されたものをできるだけ残して説明しようと思いましたが、このデコードデータにはトランザクションを作成した時点の情報に加えていろいろな情報が追加されているので、
  デコーダーによっても表記が変わるうえ、デコーダーがdescriptorなどの情報をどのようにバイトデータから抽出しているかは調べてもわからなかったです。「asm」「hex」を除き削除したほうが良いでしょうか。
   -->

  | 名称    | 説明                                                                                           |
  | ------- | ---------------------------------------------------------------------------------------------- |
  | asm     | トランザクションのロック解除条件スクリプト． UTXO の持ち主だけが使用できるようにロックをかける |
  | hex     | asm の 16 進数表記版 ．受信側が検証の際に使用する                                              |
  | address | 送金先アドレス． 送金先が記される                                                              |
  | type    | トランザクションの種類．ロックにかかわる形式が記される                                         |
  | \*desc  | 出力記述子．ウォレットやアドレス形式をサポートする                                             |

  - type では P2PK や P2SH といった形式を指定する（トランザクションの種類は[後述](#トランザクションの種類)する）
  - \*desc は様々な種類の記述しをサポートしている（今回は addr）
    - \*詳しくは (https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md) を参照のこと

`補足：scriptSig (Unlocking Script) とscriptPubKey (Locking Script)は鍵と南京錠のような、鍵における対の関係であることを理解してほしい。`

- Locking Script（UTXO にロックをかける条件スクリプト）は「asm」の項目であり、それ以外は補足の情報である

## タイムロックについて

- lockTime について「アウトプットをいつから使用可能にするかを指定する」と説明したが、タイムロックは以下のような指定方法がある
- Tx 中，nLocktime や nSequence というパラメータで表現される．

  |                      | 相対時間                     | 絶対時間                       |
  | -------------------- | ---------------------------- | ------------------------------ |
  | トランザクション単位 | nSequence                    | nLocktime                      |
  | UTXO 単位            | CSV（CHECK SEQUENCE VERIFY） | CLTV（Check Lock Time Verify） |

### トランザクション単位のタイムロック

- #### nSequence

  - Tx 中 vin に含まれるパラメータで sequence という項目がある．
    <!-- TODO 以下の説明が意味不．locktimeの説明がまだだし，「locktime に達していないトランザクションを置換するための値」とは何？Txを値で置換するとは？
    手数料によってマイナーにインセンティブがないならユーザーは手数料を上げることで対応できるし，それは一般的にBitcoinのTx全般でそうしていることと矛盾しないのでは？
    元の用途が意味不明なので消してしまって良いかも．

    => RE: BIP-68より、「ビットコイン トランザクションには、入力ごとにシーケンス番号フィールドがあります。当初のアイデアは、メモリプール内のトランザクションが、より高いシーケンス値を持つ同じ入力を使用して置き換えられるというものだったようです。これは適切に実装されていませんでしたが、たとえ低いシーケンス番号の方がマイニングの収益性が高くても、マイナーはより高いシーケンス番号を好むだろうと想定しています。しかし、マイナーが利益動機だけで行動すると、その仮定は完全に崩れてしまいます。」とあり、それを読む限りでできる説明はあのような形になってしまいました。そもそもこのBIPの記述も意味不なので削除します。
     -->
     <!-- todo vin中に含まれている値だが，Tx単位で設定するパラメータとしては不適切．各vinのsequenceが違う値だった場合はどうなる？
    
     => RE: nSequenceのロック時間を満たしていないものは使用できないので、それを利用したトランザクションのマイニングができないのではないでしょうか？それはトランザクション単位で管理されることになりませんか？
      -->

    <!-- nSequenceって4バイトでは？以下だと全数字が対象になる．というかTxが終了とは？Tx内部のパラメータでそのTxの状態を示すのは無理．

    　=> RE: 16進数表現で４バイトです。バイトデータはすべて16進数なので。最終とはファイナライズ段階にあるかどうかです。私自身この文書でファイナライズに触れていないと思うのですが、どこに書いてあるか教えていただけますでしょうか。リンクを張るなどの対応を致します。（ファイナライズについて：　https://bitcoin.stackexchange.com/questions/88289/what-is-transaction-finality）

    さらに例示されている上のJSONだとこのデフォルト値ではないのが不自然． => RE: デフォルトの4294967295で間違いないと思うのですが、どういう意味でしょうか？

    0xffffffffが設定されているとどうなるかの説明が必要．
     -->

  - 現在デフォルトでは整数最大値である「0xFFFFFFFF（4294967295）」が設定されている．

    - 「0xffffffff」の場合コンセンサスの意味を持たない（ロックを示す値として扱われない）

  - 元の用途で使用されなくなったので相対時間タイムロックとして再利用されることとなった（BIP-68 による）

    - \*これにより以下のように意味が再定義された

      | 名称         | 役割                                                           |
      | ------------ | -------------------------------------------------------------- |
      | Disable Flag | 相対時間タイムロックを使用するかのフラグ                       |
      | Type Flag    | 秒単位（512 秒単位）とブロック高単位のどちらを使用するかを指定 |
      | Value        | 時間のデータを示す                                             |

      - このタイムロックを使用できるのは、トランザクションのバージョンが 2 以上であるときである
      - 4 バイトで表現される nSequence をビットに変換(32bit)し考える．
      - 各 vin の sequence が違う値だった場合は
      - \*32 番目のビットが 1 であればロック不使用を意味し、0 であれば使用を意味する（ビットについては[以下の説明](#ビットについて)を参照のこと）
      - \*ロックを使用する場合、23 番目のビットが１であれば秒単位の使用、0 であればブロック高単位の使用を意味する
      - \*時間データは最初の 16 ビットが解釈される

        <!-- TODO 16bitが時間データ領域だった2^16=65536では？ 512秒ってどこから出てきたんだろう

        => RE: BIPに書いてある以上のことはわからないというのが返答です。おっしゃっている数字はタイムロックとして指定できる最長期間ではないですか？最大で、ブロック単位で65,535 ブロック (約1.25 年)、秒単位で 512 * 65,535 -1 秒(1.06 年)のロック期間の設定が可能です。
        -->

      - \*512 秒なのは Bitcoin の Block time が 10 分（600 秒）に設定されているためである

        - $2^8 = 256$ 、 $2^{10} = 1024$ であるため、600 に一番近い粒度の $2^9 =512$ が選ばれたと BIP には記されている

      - 以下の図はインデックスが 0 始まりなので注意してほしい（ BIP-68 の画像をそのまま再現した）

      <!-- todo 白い部分の隙間が空いている理由はなんだろう． -->

      - 以下の図で空白があるのは、ソフトフォークによって粒度を高めたり、将来的に可能な最大相対ロック時間を増やすことを可能にするため

      ![nSequenceの各ビットにおける役割](./img/nSequence.drawio.svg)

      - ロックタイムと nSequence の例を挙げるので、参考にしてほしい

        - 以下は読みやすくするため、あえてビッグエンディアンで記載している

    <!-- todo 上の例の32ビット目が1なのでロック不使用となっている．いいのこれで？ -->

        |  hex | bit列                                  | delay type   | delay          |
        | --------------- | --------------------------------------- | ------------ | -------------- |
        | 0x00400001      | 00000000 01000000 00000000 00000001 | second       | 512 sec later  |
        | 0x00300012      | 00000000 00110000 00000000 00010010 | block height | 12 block later |

        - また、シリアル化されたトランザクション（ Bitcoin core cli の getrawtransaction で得られるようなデータ）は注意が必要

    <!-- TODO sequenceってJSON中に数字で表現されているので，バイトオーダーはもう決まっているはずでは？解釈の問題とかではなく．
    => RE: バイトデータを理解する際に助けになるかと思って記載したのですが、不要なら削除します。
     -->

          - Bitcoin では、署名フィールドと公開キーフィールド以外はリトルエンディアンでエンコードされる（[エンディアンについてはこちらを参照](#エンディアンバイトオーダーについて)）
          - そのため、nSequence においてはリトルエンディアンにおけるビットが、上記図のビット位置に対応しているとする人もいる
          - しかしながら、筆者としてはビッグエンディアンでのビットの位置が、上記図のビット位置に対応すると考えている

          `要するにロック使用を明示する際も、 0xFEFFFFFF なのか、 0x7FFFFFFF なのかは BIP には明記されていないので注意してほしいということ`

  - 時間指定のインプットが複数ある場合、例えば２つの場合、2 つの条件両方を満たす場合に有効になる

  #### \*ビットについて

  - 「0」か「1」のみで表現されたデータ表現方法が「ビット」（2 進数表現）

    - 1 ビットでは「0」「1」の 2 通りの表現ができる
    - 例えば 5 ビットでは $2^5 = 32$通りの値が表現できる

  - また、　$N$ 個の文字の種類で表せる値を $N$ 進数という

    - 2 進数とは、「0」、「1」の 2 種類の文字のみで表現される数値
    - 16 進数とは、「0」、「1」、・・・、「F」の 16 種類の文字で表現される数値

  - したがって、16 進数 1 文字を現すには $2^4 = 16$ より、4 ビット必要

    - 例えば、4 文字の 16 進数「0xE9F4」は以下の画像のようなビット配置になる（「0x」は 16 進数を表すマーク）
      - bit 表記では「1110100111110100」

  - そして 8 ビットが「1 バイト」である

    - したがって、16 進数は「1 バイト」を 2 桁で表現される．

      ![bit配置の例](./img/bit.drawio.svg)

  #### \*エンディアン（バイトオーダー）について

  - エンディアンとは、バイトデータの並び順のこと

    - より正確には、 2 バイト以上のデータの、メモリへの格納方式及びデータ送信順序のことである

  - エンディアンには 2 種類ある

    | 名称               | データの並べ方                   |
    | ------------------ | -------------------------------- |
    | ビッグエンディアン | 最上位のバイトからメモリに入れる |
    | リトルエンディアン | 最下位のバイトからメモリに入れる |

    ![エンディアンの例](./img/endian.drawio.svg)

  - 16 進数をリトルエンディアンで並べた際には以下のようになる

  ![16 進数をリトルエンディアンで並べた例](./img/endian-hex.drawio.svg)

- #### nLockTime

  - nLockTime が指定されたトランザクションは指定時間まで有効なトランザクションとみなされない

    - 検証に失敗するためトランザクションプールにもたまらないし、伝搬もされない
    - これによって、アウトプットは指定された時間まで使用できない
    - しかし、アウトプット（送金する資金）の資金源となる、インプットの使用は制限されていない
    - したがってロックが解除されたときには、トランザクションが無意味になっている（送金元アウトプットがすでに UTXO でなくなった）可能性がある
      - ロック解除までに同じアウトプットをインプットとする有効な Tx が作れるため．

  - この問題を解決するために生まれたのが CLTV (Check Lock Time Verify)である
  - \*また、nLockTime は値の範囲で意味が異なる
  - nSequence との違いは，ロック期間を nSequence が相対時間を指定できるのに対しこちらは絶対時間を指定する．

    | 範囲                          | 意味                                                  |
    | ----------------------------- | ----------------------------------------------------- |
    | $nLockTime = 0$               | タイムロックなし                                      |
    | $0 < nLockTime < 500,000,000$ | そのトランザクションが有効になるブロック高            |
    | $500,000,000 < nLockTime$     | そのトランザクションが有効になる Unix Epoch Timestamp |

### UTXO 単位のタイムロック

- #### CSV (Check Sequence Verify)

  - マイニングされブロックに取り込まれた時間に対して、特定のブロック数または秒数が経過するまで UTXO の使用が制限される
  - ライトニングネットワークなどのスケーリングソリューションで用いられている
  - nSequence が Tx に対応した相対時間のロックを実現するパラメータだったのに対して，こちらは UTXO に対応する相対時間のロックを実現する．

        - ライトニングネットワークは、P2P において 2 者が双方向に支払いチャネルを開くための支払いプロトコル
        - ビットコインと同じく、第 3 者を信頼して取引をするわけではないため、不正確さや不正行為を防止する役割で CSV が使われる
        - 例えば一方が不正をしているのが発覚したとき、CSV の遅延があることで、その対処をすることができる

  - CSV を使用するためには Locking Script で`OP_CHECKSEQUENCEVERIFY`を使用する
    <!-- todo CSVはどうやって実現するか書く必要あり．Bitcoin Script？ -->

- #### CLTV (Check Lock Time Verify)

  - UTXO に対する絶対時間タイムロックを実現する

    - 2015 年に Bitcoin Script に加えられた
    - 資金をタイムロックの時点まで使用不可能にし、nLockTime での問題を解決した

  - \*以下のようなロッキングスクリプトになる

    - 例えば、トムがアレキサンダーにお金を支払う例。1 か月後に有効になるロッキングスクリプトとなっている

      `<now + 1 months> CHECKLOCKTIMEVERIFY DROP DUP HASH160 <Alexander's Public Key Hash> EQUALVERIFY CHECKSIG`

    - <now + 1 months> は nLockTime と同じく 5 億を閾値とする．
      - 具体的な日付・時刻を入れる．
    - この UTXO を Input とするトランザクションを作成するときは以下に留意する

      - アンロックスクリプトにはアレキサンダーの署名と公開鍵を入れる
      - トランザクション内の nLockTime を 1 か月後以降にする

        ```
        設定されているnLocktimeが <now + 1 month> より小さかったら実行は停止（無効とされる）、大きかったら続行される。
        そもそも現在時刻が指定されているnLocktimeより大きい場合は、そのトランザクションは無効となり伝搬されない。
        ```

# トランザクション手数料

- **トランザクション手数料**とは、**トランザクションをマイニングするマイナーに対するインセンティブのこと**

  - 経済的な合理性から、マイナー達は基本的にデータサイズに対して手数料が高いトランザクションを選択しブロックに取り込む

- 手数料にはスパム防止の意味合いもある

  - 仮に手数料がなかったとしたら、例えば次のようなスパムが考えられる

    - ダストトランザクション：　極小の金額を送金するトランザクションを大量に作成し、ネットワークを圧迫する
    - 自分宛てに送金：　ひたすら自分に送金し続けることで、UTXO セットやネットワークを圧迫する

- 適切な手数料はトランザクションのデータサイズによって左右される

  - データサイズが手数料を決定する
  - したがって、vin や vout に記述される量は少ないほうが、手数料は安くなる

- マイナーに渡される手数料は以下の式で算出される

  $TransactionFee = Sum(vinで指定されているvoutのvalue) - Sum(voutのvalue)$

多くの場合、ウォレットが自動的に手数料を計算して支払っている

- だが手数料は自分で指定することもできる
- 優先して処理したいトランザクションであれば、手数料を増加させれば優先的にマイニングされ，より早くブロックに取り込まれることが期待される．
- 逆に手数料がデータサイズに対して過少であると、ずっとマイニングされない可能性もある

- したがって、手数料は市場原理のように決定される
- ノードによっては、フラグを立てておくことで、すでに送信したトランザクションの手数料をあとから変更することもできる
  <!-- TODO どうやって実現しているか要確認 => RE: ノードによって実装の仕方が異なるのでまとめるのは難しそうです。一見共通しているのは交換可能性をフラグで示すことだけのようです。 -->
  - \*オプトイン RBF（BIP-125）などがある
  - \*フラグには nSequence を使用する（参考：[BIP-125 におけるフラグの立て方](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki)）
  - これはすでにブロードキャストしたトランザクションを取り下げることができる機能ではない
  - あくまでも手数料を高いものに置換しなおすことで、ブロックへの取り込み速度向上を期待できるというものである

# トランザクションの種類

- 以下が 旧来からの Bitcoin における 5 つの標準的なトランザクションである
  - これら以外にも P2TR （Pay to Taproot）などがある - 参考リンク (https://medium.com/geekculture/understanding-bitcoin-transaction-output-types-with-bigquery-c625643f2ab5)
  - P2TR と P2WPKH については[後述](#トランザクション方式について)
  <!-- todo P2TRとP2WPKHがTaprootによって新しく追加された部分？もしそうならそれも追加で記述が必要．=> RE: 違います。P2WPKHを単に消し忘れました。 -->

| 名称                           | 説明                                      |
| ------------------------------ | ----------------------------------------- |
| Pay-to-Public-Key-Hash (P2PKH) | 標準的な送金トランザクション              |
| Pay-to-Public-Key              | Coinbase トランザクションで使用されている |
| Multi-Signature                | 複数人の署名が必要なトランザクション      |
| データアウトプット(OP_RETURN)  | 支払いとは関係ないトランザクション用      |
| Pay-to-Script-Hash (P2SH)      | より複雑な処理が可能なトランザクション    |

- Bitcoin Script が多く出てくるので、忘れてしまっていたら[ここ](#bitcoin-script)を見直してほしい

## Pay-to-Public-Key-Hash (P2PKH)

- P2PKH は Bitcoin アドレスに支払う場合に使われる
- 2023 年までは P2PKH が一般的な送金処理において使用されていた

  - 現在は「Taproot」が主流になりつつある（[Taproot](https://academy.binance.com/ja/articles/what-is-taproot-and-how-it-will-benefit-bitcoin)とは）
  <!-- todo Taproot以降についてもそう？ => RE: 2023年頭から変動しながらではありますが、50%近くを占めているようです。https://transactionfee.info/charts/transactions-spending-taproot/
  記述を変更します。
  -->

- ### 使用されているオペコードの役割

  | 名称           | 役割                                                                                                      |
  | -------------- | --------------------------------------------------------------------------------------------------------- |
  | OP_DUP         | スタックの１番上の要素を複製してスタックに push する                                                      |
  | OP_HASH160     | SHA256 を計算し，その値に対して RIPEMD160 を通す関数（HASH160 関数）．ハッシュ関数を 2 回通すことになる． |
  | OP_EQUALVERIFY | 2 つの入力を比べ、一緒なら True、異なると False を返し、最後に OP_VERIFY を実行する　                     |
  | OP_CHECKSIG    | デジタル署名が公開鍵で検証可能かをチェックする．                                                          |
  | ( OP_VERIFY )  | スタックの１番上の要素が true 以外の場合、トランザクションを無効としてマークする                          |

- ### Unlocking / Locking Script のフォーマット

  <!-- todo LockingScriptがvinで参照されるアウトプットに含まれていて，Unlocking Srcriptは今回作成するTxのvin部分で新たに作ることを記す -->

  - LockingScript は vin で参照されるアウトプットのものを使用し、Unlocking Srcript は今回作成する Tx の vin 部分で新たに作成される

  - Locking Script

    `OP_DUP OP_HASH160 <送金先アドレスの公開鍵ハッシュ> OP_EQUALVERIFY OP_CHECKSIG`

    - `<送金先アドレスの公開鍵ハッシュ>`はアドレスを Base58 でデコードした値

  - Unlocking Script

    `<送金先アドレスに対応する署名> <送金先アドレスの公開鍵> `

  - つなぎあわせた以下の Script が True になれば OK

    `<Unlocking Script> <Locking Script>`
    `<送金先アドレスに対応する署名> <送金先アドレスの公開鍵> OP_DUP OP_HASH160 <送金先アドレスの公開鍵ハッシュ> OP_EQUALVERIFY OP_CHECKSIG`

  - やっていることは次の２つ

    - インプットにある公開鍵がアウトプットのものと同じかどうかがチェック
    - その公開鍵で署名の検証が可能か、すなわち秘密鍵をもっているかをチェック

  - #### 署名対象のメッセージについて

    - 署名対象のメッセージは非 SegWit トランザクションと SegWit トランザクションで変わる

      - ここでは非 SegWit トランザクションの署名対象について紹介する
      - SegWit トランザクションの署名対象が知りたい人は[ここ](https://learnmeabitcoin.com/technical/keys/signature/#segwit-algorithm)を参照のこと

    - 署名対象一覧は以下の通り

      - nVersion
      - vin
        - txid
        - vout
        - scriptSigSize
        - scriptSig
          -nSequence
      - vout
        - value
        - scriptPubKeySize
        - scriptPubKey
      - locktime
      - sighash

  ```
  sighash について

  「scriptSig（Unlocking Script）について」のセクションでもすでに出てきていた sighash だが、以下のような種類がある

    1. SIGHASH_ALL
    2. SIGHASH_NONE
    3. SIGHASH_SINGLE

  sighash は組み合わせることができるのでこれら以外にも種類が多くあるのだが、気になった人はリンクを参照のこと。（https://wiki.bitcoinsv.io/index.php/SIGHASH_flags）

  これらは、トランザクションのどの部分に署名をするか（他人が書き換えられないようにするか）を指定するためのフラグである。
  基本的には（デフォルトでは）、トランザクションに関するすべてに署名する、 1. SIGHASH_ALL を使用して署名される。
  （しかし、トランザクション作成時に自己参照に陥るため、 Unlocking Script までを署名に含めることはできない。これはどの sighashも同じ。）

  2 はすべての vin に署名するが、vout は署名しない。3 はすべての vin と、署名される入力と同じインデックスを共有する出力に署名する。

  sighash を使用することで、例えば、vin を書き換え可能にしておきBitcoinを募るといった、クラウドファンディングのようなことができるそう。
  ```

  <!-- todo 署名の対象としているMSGは何なのか要確認．-->

## Pay-to-Public-Key

- 主に coinbase トランザクションで使用される
- P2PKH よりシンプルな送金形式で、公開鍵ハッシュではなく公開鍵そのものを使用する

  - 通常の送金時に使用する場合、送金先アドレスだけでは不十分で，公開鍵が必要になる
  - 公開鍵そのものはアドレスから抽出できないので、通常の送金では使いにくい

- ### Unlocking / Locking Script のフォーマット

  - Locking Script

    `<送金先アドレスの公開鍵> OP_CHECKSIG`

  - Unlocking Script

    `<送金先アドレスに対応するデジタル署名> `

  - つなぎあわせた以下の Script が True になれば OK

    `<Unlocking Script> <Locking Script>`
    `<送金先アドレスに対応するデジタル署名> <送金先アドレスの公開鍵> OP_CHECKSIG`

## Multi-Signature

- ロッキングスクリプトにいくつかの公開鍵を登録しておき，そのうちのいくつかの署名をアンロッキングスクリプトで必要とするトランザクション
  - 複数の署名がないと送金できないようにしたい場合に使用する（供用する場合など）
- Bitcoin だけの概念ではなく、一般に「M-of-N スキーマ」として知られているものである
  - $N$ 個の公開鍵のうち、少なくとも $M$ 個の対応する署名が必要（ $M \leqq N$ ）
  - 例えばよく使われる 2-of-3 マルチシグネチャの場合は、3 個の公開鍵のうち 2 つの署名が必要
- マルチシグネチャ script では最大 15 個の公開鍵が使用可能

  - しかし`Support up to x-of-3 multisig txns as standard`と書かれている

    （https://github.com/bitcoin/bitcoin/blob/master/src/policy/policy.cpp#L80）

  - P2SH にラップされたマルチシグネチャスクリプトにおいては 15 個まで使用できる模様

- ### 使用されているオペコードの役割

  | 名称             | 役割                                                                       |
  | ---------------- | -------------------------------------------------------------------------- |
  | OP_CHECKMULTISIG | 設定された N 個の公開鍵に対応するデジタル署名が M 個揃っているかを検証する |
  | OP_0             | 空のバイト配列をスタックに push する                                       |

- ### Unlocking / Locking Script のフォーマット

  - Locking Script

    `M <公開鍵 1> <公開鍵 2> ... <公開鍵 N> N OP_CHECKMULTISIG`

    - `M`、`N`は M-of-N の数字

  - Unlocking Script

    `OP_0 <デジタル署名1> <デジタル署名2> …`

    - `OP_CHECKMULTISIG`は実行した時に、処理に関係のないスタック上の要素を余分に 1 つ pop してしまうバグがある
    - そのため余分な`OP_0`を入れておく
    - この`OP_0`は`OP_CHECKMULTISIG`に無視される

  - つなぎあわせた以下の Script が True になれば OK

    `<Unlocking Script> <Locking Script>`
    `OP_0 <デジタル署名1> <デジタル署名2> … M <公開鍵 1> <公開鍵 2> ... <公開鍵 N> N OP_CHECKMULTISIG`

## データアウトプット（OP_RETURN）

- 支払いには関係がないトランザクションを作成する場合に使用する

  - このときトランザクションはブロックチェーンによって改ざん不可能なデータとして活用できる
    - これはデータの存在証明(Proof of Existence)に使用することが可能

- 使用不可であるアウトプット（Locking Script）で構成される

  - そのため対応する Unlocking Script は存在しない

- ### 使用されているオペコードの役割

  | 名称      | 役割                                   |
  | --------- | -------------------------------------- |
  | OP_RETURN | トランザクションを無効としてマークする |

- ### Unlocking / Locking Script のフォーマット

  - Locking Script

    `OP_RETURN <data> `

    - `<data>`は 80 バイト

  - Unlocking Script

    - 存在しない

## Pay-to-Script-Hash (P2SH)

<!-- todo 受け取り側の都合により送金側のTxサイズが大きくなってしまっていたのを解消，ということを最初に書く -->

- 受け取り側の都合により送金側の Tx サイズが大きくなってしまっていたのを解消した

  - これは手数料削減にもつながる

- 複雑な script を単純化できるようにしたもの

  - 複雑なスクリプトを使用するのは現実的に難しい（以下の[例](#p2sh-の使用例)を参照）

- スクリプトそのものの代わりにそのスクリプトのハッシュ値をロッキングスクリプトに用いる

  - そのスクリプトをリディーム（引き換え）スクリプト（Redeem script）と呼ぶ
  - これにより，複雑な長いスクリプトはアンロッキングスクリプト内に含まれることになる

- ### P2SH の使用例

  #### 状況

  - 2-of-5 マルチシグでの P2SH の利用を考える

    ```
    とある会社では会社のアドレスからの送金に，社長と役員3人，弁護士の計5人のうちの2人の署名が必要としている。
    顧客からの支払い先にこのアドレスを使っている
    ```

  #### P2SH を使用する理由

  - マルチシグをそのまま利用すると以下の問題がある

    - 支払い前に受け取り側のいくつかの公開鍵の共有が必要
    - 公開鍵を複数含むためスクリプトサイズが大きい
    - UTXO プールを圧迫したり、手数料が増加したりする
    - 受け取り側の都合で、本来関係ないはずの送金側に余計な手数料負担が発生してしまう

  - P2SH はこのような問題を解決できる
    - 送金側で必要な手続きが減る
    - 長いスクリプトはアンロック側（資金を受け取る側）になるため、送信者に高額な手数料がかからない

  #### Script

  - Redeem Script

    ```
    2 <自分の Public Key> <パートナー1の Public Key> <パートナー2の Public Key> <パートナー3の Public Key> <弁護士の Public Key> 5 CHECKMULTISIG
    ```

  - Locking Script

    `OP_HASH160 <20-byte hash of Redeem Script> OP_EQUAL`

    - `<20-byte hash of Redeem Script>`は Redeem Script を、HASH160（Double hash）に通したもの

  - Unlocking Script

    `<Sig1> <Sig2> <Redeem script>`

  #### 実行

  - 通常の Bitcoin Script の実行手順と少し異なる

    1. `<Redeem Script> <Locking Script>`が`True`かを確認する
    2. `True`なら`<Unlocking Script> <Redeem Script>`が実行される
    3. 2.の Script が True になれば OK

  - アンロック処理の実行の前に、署名対象（アンロック対象）が適切か（意図したものか）どうかを確認している

    (https://learnmeabitcoin.com/technical/p2sh) より引用

### P2SH の利点

- トランザクションのデータサイズを小さくすることができる

  - 手数料の削減
  - UTXO サイズの削減

- Script はアドレスとして実装されるので、ウォレットは P2SH に関する複雑な実装の必要がない

  - 取引の簡略化

- 長いスクリプトのトランザクション手数料は、受け取り側が支払うようにできる

  - 受け取り側は払う側に負担を強いる必要がなくなる

- 複雑な送金処理ができる
- P2SH アドレスとして通常の Bitcoin アドレスと全く同じように使用することができる
  - \*P2SH を Base58 encode して使用する
  - \*Version Prefix には「5」を使用し、アドレスは「3」から始まる

### P2SH の注意点

- 設計上、再帰処理ができない

  - すなわち、P2SH Redeem Script の中に P2SH を置くことはできない

- Redeem Script の中で`OP_RETURN`を使用することはできない

  - すなわち、OP_RETURN トランザクションは使用不可

- 正しくない Redeem Script を作成すると、使用できない UTXO が生まれる
  - Redeem Script はアンロックされて実行されるまで検証されない（ハッシュ化されているため）
  - したがってエラーも出ないし、UTXO の使用もできないといった事態が発生しうる

# Coinbase トランザクション

- **Coinbase トランザクション**とは、**マイナーへの報酬を支払うためのトランザクションのこと**

  - 誰かから資金を移動するのではなく、新しく Bitcoin を生成するトランザクション
  - したがって、vin に UTXO は含まれない

- vout には複数のアドレスを指定可能

  - 要するに通常のトランザクションと同じ構造
  - しかし[後述](#coinbase-トランザクションの-vin-について)するように、vin だけ少し特殊になっている

- このトランザクションは、ブロックに１つだけ存在する

  - ほとんどの場合トランザクションの１番最初に位置する

- このトランザクションのアウトプット総額は以下のように決まる

  - ブロック内の各トランザクションの手数料の合計
  - ブロック高に対する半減期を考慮したマイニング報酬
  - 式にすると以下のようになる

    $totalVout = Sum(transactionFees) + halvingRelative$

    $halvingRelative$ は[半減期](#4-マイニング)によって変動する報酬（Bitcoin）のこと

## Coinbase トランザクションの vin について

- UTXO をインプットにとらないため、以下の項目は一定である

  | 名称      | 値               |
  | --------- | ---------------- |
  | txid      | 32 バイトの null |
  | index     | 0xffffffff       |
  | nSequence | 0xffffffff       |

- 新たに Bitcoin を生成する性質上、Unlocking Script が不要

  - したがってマイナーは、Coinbase トランザクションの Script には任意のデータを入れることができる
  - これは「Coinbase Script」と呼ばれている
  - 使用可能なデータサイズは 2 ~ 100bytes
  - \*一般的にマイナーは、マイニング プールを識別する追加のナンス値と文字列を置く

- \*また BIP-34 に従って、「version」が 2 のブロックではブロックの高さを含める必要がある

- 創設者の「Satoshi Nakamoto」も「Coinbase Script」で遊んでいる（有名なので紹介する）

  - `The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.`
  - 英国タイムズ紙のその日の見出しらしい（マイニング開始の日付を残すためだとか）

## Coinbase トランザクションの承認について

- Bitcoin は新規ブロックを最長のチェーンにつなぐというルールがある

  - これは、最長のチェーンは最も労力（PoW）をかけて検証された、最も信頼できるものであるということから
  - これにより、ブロック生成で競合が起こってもチェーンが分裂するのを防いでいる

- Coinbase トランザクションは、少なくとも 100 回の確認を受ける（100 ブロック後）まで使用できない

  - これは、マイニングによってチェーンにフォークが生じてしまった際にも、損失が起こらないようにするためである

    - 例えば、100 回の確認がいらない状況下で、フォークによってチェーン X と Y ができたとする
    - そして X で得られた Coinbase トランザクションのアウトプット 10BTC を即座に送金したとする
    - しかし、Y が最長チェーンとなり X が破棄されると、X で生成された 10BTC も破棄される
    - そうすると、X で生成された 10BTC を受け取った人は、急に自身のアドレスから 10BTC が消失する

  - このような受け取り側の損失を防ぐために、Coinbase トランザクションでは、最長チェーンが確定するまでの猶予を持たせている

  （参考：(https://bitcoin.stackexchange.com/questions/1991/what-is-the-block-maturation-time) ）

# \*SegWit（Segregate Witness）

- **SegWit**とは、**署名データをトランザクションデータから分離したトランザクション方式のこと**

  - 署名データの扱いに関しては後述の[データ構造について](#データ構造について)を参照のこと

- SegWit は 2017 年にソフトフォークとして実装された

  - ブロックに入れられる容量を増やすために実施された
  - SegWit によってブロックに入れられるデータ量の上限は**4MB になった**

- しかし、SegWit を導入していないノードでも、計算上ブロックサイズが 1MB に収まるようになっている

  - SegWit でも、マイニングするためのハッシュ計算対象の情報は従来と変わらない
  - それはマイニングのコストが変わらないようにするため

  ```
  実際にはSegWit導入に伴ってBitcoinのコードが既存のものから書き換えられた。（ブロックサイズ上限の定数など）
  「ソフトフォーク」は、Backward-compatible（後方互換）である変更であり、ハードフォークはそうではない変更である。
  従来のTxも新しいプロトコル（SegWit）で有効であるので、この変更はソフトフォークであるといえる。
  ```

  - コードの変更履歴は[ここ](https://github.com/bitcoin/bitcoin/commit/3babbcb48786372d4b22171674c4cc5a6220c294#diff-74d3d558e2ae1b1c967ea13d01ce15875cc7de50c93c26db73ccb3e4db5cfdacL15)を参照

## SegWit の導入理由について

- SegWit は以下の問題を解決するために導入された

  - #### トランザクションデータの削減（効率化）
  - #### 取引速度の向上
  - #### トランザクション展性（Malleability）の克服

---

### トランザクションデータの削減（効率化）

- 前述したように、Bitcoin のブロックサイズは１ MB という制約がある

  - 署名データは最大でトランザクションデータのおよそ 65%ほどを占める
  - そこで Unlocking Script のデータを「Witness Data」に移すことによって、トランザクションデータの拡張を実現している

- これによって得た上限は４ MB である

- 1 つのブロックにより多くのトランザクションを含めることができるようになった

### 取引速度の向上

- １つのブロックにより多くのトランザクションが含まれることで、１秒間に処理できる件数（TPS）も多くなる
- これにより、ネットワークの混雑が緩和され手数料も安くなる

### トランザクション展性（Malleability）の克服

- トランザクション展性（Malleability）とは、トランザクション ID の改ざん可能性のこと

  - もう少し直感的に言うなら、トランザクションの意味を失わないようにしたまま、txid を変更すること
  - これにより２重支払いが引き起こされる可能性がある

- txid は Unlocking Script を含めたトランザクションデータをハッシュの対象にする

  - アンロックに無害なスクリプトを追加すれば、txid だけ変わる（`OP_NOP`など何もしないオペコードを追加するなど）
  - 同じトランザクション内容なのに txid だけ変わると、不一致が起こる（作成したトランザクションが見つからないなど）
  - 自身の作る同じ UTXO から同じ金額の Tx でも txid が異なる Tx をいくつも生成できてしまうことを意味する．

- SegWit は Unlocking Script を「Witness Data」に移動することで、この脆弱性に対応した

  - それゆえ SegWit の Unlocking Script は基本的には空でないといけない

    - BIP-16 プロトコルにネストされた時などはこれに限らない（詳細は[ここ](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#user-content-P2WPKH_nested_in_BIP16_P2SH)を参照のこと）
    <!-- todo 同じWitnessで同じようにUnlockingSrcriptに意味のないスクリプトを埋め込めばtxid変えられるのでは？ -->

  - txid の作成において Witness Data は無視されるから

- この改善によって「ライトニングネットワーク」が実用可能になった
  <!-- todo Segwit以前にもLightning Networkってあったのでは？ -->
  - オフチェーンでのシステムを安全に展開できるようになった

---

## ブロックウェイト（Block Weight）

- 以下の式で定義される値を「ブロックウェイト」という

  これは，Segwit においてブロックの大きさを表す表現方法．

  $BlockWeight = nonWitnessDataSize*3 + TotalDataSize = nonWitnessDataSize*4 + WitnessDataSize$

  - $nonWitnessDataSize$ は Witness Data を除いたブロックサイズ
  - $TotalDataSize$ は Witness Data も含めた全体のブロックサイズ

    - すなわち、 $TotalDataSize = nonWitnessDataSize + WitnessDataSize$
    - ブロックサイズの上限は変わっていないため、 $0 < TotalDataSize \leqq 1MB$

  - $BlockWeight$ の単位は「Weight Unit（WU）」（上記式では MWU）と表現される．
    - 単位は Byte，MegaByte と同じ（1 WU = 1 B, 1 MWU = 1 MB）
  - また、 $0 < BlockWeight \leqq 4,000,000 WU$ である

- **SegWit 対応ノードではブロックウェイトが、ブロックサイズに代わる１ブロックあたりの容量の制限となる**
  - すなわち、ブロックサイズが１ MB 以内という制限ではなく、**ブロックウェイトが 4,000,000WU 以内という制限に置き換わる**

## ブロックサイズについて

### 非 SegWit トランザクションの場合

- Witness Data が存在しないため$witnessDataSize = 0$、すなわち$TotalDataSize = nonWitnessDataSize + 0$ より $TotalDataSize = nonWitnessDataSize$
- また $TotalDataSize \leqq 1MB$ より、 $nonWitnessDataSize \leqq 1MB$
- したがって、 $BlockWeight = nonWitnessDataSize*3 + TotalDataSize \leqq 1*3 + 1 = 4$
- 以上より、ブロックウェイトが 4,000,000 WU 以内という条件と同値である（この条件で後方互換性を保てる）

### SegWit トランザクションの場合

- $0 < BlockWeight \leqq 4,000,000WU$であり，Segwit Tx の場合は $0 < nonWitnessDataSize$ 、 $0 \leqq WitnessDataSize$ である

- $0 < nonWitnessDataSize < 1$ なので

$4 \geqq  BlockWeight  = nonWitnessDataSize*4 + WitnessDataSize >  WitnessDataSize$

すなわち

$0 \leqq WitnessDataSize < 4$

である（単位は MB）

- 実際データサイズは、1 ～ 2.2 MB の範囲であることが多いようだ

## データ構造について

- 従来のトランザクションのデータ構造に、新たに以下の項目が追加される

  | 名称    | 説明                                    | 役割                         |
  | ------- | --------------------------------------- | ---------------------------- |
  | marker  | 1 バイトの値`0x00`                      | SegWit であることを示す      |
  | flag    | `0x00`以外の 1 バイトの値、現在は`0x01` | SegWit の互換性を示す        |
  | witness | witness データをシリアル化したもの      | 署名に関わるデータを保持する |

- 比較すると以下のようになる

  - 従来のトランザクション構造

  ![レガシートランザクションのデータ構造](./img/transaction-structure-detail.drawio.svg)

  - SegWit トランザクションの構造

  ![レガシートランザクションのデータ構造](./img/SegWit-transaction-structure-detail.drawio.svg)

  - 赤の部分が SegWit で追加された部分、破線がなくなった部分

- このように、署名データは ScriptSig から分離され、nLockTime の直前に witness として配置される

- また witness は署名データであるが、ScriptSig のような Bitcoin Script ではないことに注意

  - witness には Bitcoin Script によって処理される情報が入っている
  - したがって P2WSH、P2WPKH ではそれぞれで期待されるデータが違う

- Ordinals というプロトコルは Witness 領域に独自のデータを埋め込んで実現している

  - Ordinals については[ここ](https://academy.binance.com/ja/articles/what-are-ordinals-an-overview-of-bitcoin-nfts)を参照のこと
  - 簡単に言うと、Ordinals は Bitcoin に写真やビデオ、オーディオなどの追加価値を持たせることができるようになるプロトコルである

- `witness`のデータ構造は以下のようになっている

  | 名称         | 説明                             | 役割                                    |
  | ------------ | -------------------------------- | --------------------------------------- |
  | item_counter | witness_data の数を表す          | vin と witness フィールドとを関連付ける |
  | size         | 後続のデータのサイズを表す       | 署名検証に必要な情報を提供する          |
  | witness_data | 署名値や公開鍵で構成されるデータ | 署名データを保持する                    |

- item_counter と size に使われる数字は、「Compact size」と呼ばれるフォーマットである

  - 参考 (https://learnmeabitcoin.com/technical/general/compact-size/)

- witness の構成例（P2WPKH の場合） `02 47 <署名値 71byte> 21 <公開鍵 33byte>`

  - これは witness データそのものである
  - 前から順に item_counter、 size、witness_data、size、witness_data（本来スペースは存在しないが、見やすさを考え筆者が挿入した）
  - このように item_counter は witness の先頭にだけ存在する
  - item_counter は witness_data の数を表す

<!-- TODO scriptPubKeyではなくscriptSig (Unlocking Script)では？LockingのほうだとコインベースTxからマイナーが送金する際に関係してしまう．
https://en.bitcoin.it/wiki/BIP_0141
ここを見るとやはりscriptPubKeyと書いてあった．OP_RETURNなので処理されない領域．OP_RETURNに続いて，普通のLocking Scriptが書いてある？そうしないとマイニング報酬が受け取れない．コインベースからのvoutを２つ作って，そのうちの一つがこのコミットメントを表現している，ということかも．

=> RE: その解釈であっていると思います。実際 Bitcoin scan でトランザクションを確認した限りでは、コインベースからのアウトプットは最低二つはありました。マイナーへの送金アウトプットとコミットメントでした。

コミットメントとあるが・・？　=> RE: コミットメントとあるが・・？ 何が言いたいのでしょうか？ハッシュツリーへのコミットメントという意味ではないのですか？

マークルツリーっていうことは，ブロック内の Tx で witness があるものを使ってマークルツリーを作っているっていうこと？
なんでそんなことしているんだろう．通常の Tx のマークルルートだけではなぜ不十分なのか．

=> RE: 以下にあるように Witness はいったん Witness データだけでハッシュツリーを作成するようです。そのデータをコインベースのハッシュに組み込み、マークルルートを確認することで Witness データが改ざんされていないことを担保するのではないでしょうか。SegWit ではマークルツリーを作成する際に Witness は含めないそうです（txid を使用するため　https://learnmeabitcoin.com/technical/block/merkle-root/）。

135 バイトの署名値とは？Bitcoin の ECDSA 署名は 512bit だったはず．
この witteness_data が署名の代わりに使われ，実質 1MB→4MB を実現しているコアの部分のはずなためもっと詳しく説明すべき．

=> RE: ここはSegWitのデータサイズのコアではありません。SegWitのコアはそもそものサイズの上限が変更されたことです。しかしその変更は後方互換性がある、というのがSegWitのすべてです。SegWitであってもトランザクションのデータは1MBしか含めることができません。しいて言えばUnlocking Scriptが占めていた容量を追加で使えるようになったくらいです。正直現在の説明からどういう内容を追加すれば理解できるようにできるか自分ではわからないです。Bitcoinのソースコードも、

/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */
static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;

となっているところからも実質4MBをサポートしているのは何も不思議ではありません。

公開鍵もなぜ 52byte？
楕円曲線上の点なので 64byte じゃない？圧縮された公開鍵でも 33byte だが・・．

=> RE: こちらのミスでした。修正しました。
-->

- Witness データは改ざん対策として、Witness データのルートハッシュを、Coinbase トランザクションの scriptPubKey (Locking Script, Coinbase Tx では任意の値を入れられる)においている

  - ルートハッシュの計算方法は Merkle tree と同じ
  - scriptPubKey は`0x6a24aa21a9ed <Double-SHA256(witness root hash | witness reserved value)>`　（witness root hash と witness reserved value のダブルハッシュ）
  - `witness reserved value`は容量確保のための予約語で、現在はコンセンサスの意味はない
  - なので 32 バイトの`0000 ... 0000`が設定されることが多いよう

  <!-- todo これ，意味としては式の中は「|」でビットのORを取っているということで実際は何も計算してなくてwitness root hashだけの値をダブルハッシュしているってこと？
  => RE: witness root hash と witness reserved value のダブルハッシュです
   -->

## トランザクション方式について

- 署名の効率化を行う提案である「BIP-143」にて示されている
- Segwit で追加された Tx の種類は 2 種類で、 P2WPKH、P2WSH である
- それぞれのトランザクションの種類は Locking Script で「何バイトのハッシュが使われるか」で判別される
- 以降の例では P2SH によってラップされていないものを提示する

  - P2WPKH,P2WSH の Tx は P2SH の記法で内包できるが、その場合では以下に挙げる例とは少し構成が変化する
  - ラップされた場合のコードがどうなるかは[BIP-141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#examples)を参照のこと
  - ラップすることで SegWit を直接サポートしていないウォレットやサービスと互換性を持てる

### Pay-to-witness-public-key-hash （P2WPKH）

- [P2PKH](#pay-to-public-key-hash-p2pkh) の SegWit バージョンが P2WPKH である
- P2WPKH は 20 バイトのハッシュを使用する

- #### Unlocking / Locking Script / Witness のフォーマット

  - Locking Script を対応する Vin における Unlocking Script で解除する，というのではなく代わりに Tx 内のフィールドに規定されている Witness で解除するように変わった．
  - また、Locking Script は ScriptCode と呼ばれるものに変換されて使用されるようになる（ScriptCode については少し下に記載している）

  - Locking Script

    `OP_0 14 <20-byte-key-hash>`

    - `<20-byte-key-hash>`は受け取り側の公開鍵を HASH160 関数に通した値

    - 先頭の文字が`0014`になる
    - `00`が`OP_0`、`14`が`OP_PUSHBYTES_20`

    - `00`は「バージョンバイト」と呼ばれ、この ScriptPubKey が P2WPKH または P2WSH であることを示す
    - `48`は後続の 20 バイト（key-hash）をスタックにプッシュするという意味 (OP_PUSHBYTES_20)

    - ただ、`OP_PUSHBYTES_<数>`はオペコードとしては扱わない

    ```
    OP_PUSHBYTES_<数> はBitcoinのコードに定数として用意されているオペコードではないため、表記されないことが多い。
    この文書では、OP_PUSHBYTES_<数> という形ではなく https://en.bitcoin.it/wiki/Script に表記されているような
    対応する16進数を一応表記しておく。したがって、以降の文章で出てくる 1 バイトの、 0x01 - 0x4b の間の数は無視して構わない。
    どれも後続の何バイトかをスタックにプッシュするという意味である。
    ```

<!-- todo OP_PUSHBYTES_20が消えている解釈がわけわからん．普通にOPコードいれて14と対応している，ということではない？

=> RE: OP_0 OP_PUSHBYTES_20 <20-byte-key-hash> という構造なのですが、(https://en.bitcoin.it/wiki/Script) によると、
「スクリプトについて話すとき、これらの価値を押し出す言葉は通常省略されます。」の欄に N/A 表記されており、Bitcoinのコードにも定数として用意されていないので asm形式の部分では排除しています。
分かりにくければ追加します。
-->

- Unlocking Script

  - 空である
  - 従来の、Locking Script を解除するための Unlocking Script という対応ではなくなっている
  - 代わりに Witness が使用される

- Witness

  `48 <署名値 72byte> 21 <公開鍵 33byte>`

  - `48`は後続の 72 バイト（署名値）をスタックにプッシュするという意味 (OP_PUSHBYTES_72)
  - `21`は後続の 33 バイト（公開鍵）をスタックにプッシュするという意味 (OP_PUSHBYTES_33)

- つなぎあわせた以下の Script が True になれば OK

  `<Witness> <ScriptCode>`

  - `ScriptCode`は Locking Script から情報を抽出し、Locking Script の代わりに使用される

  - `ScriptCode`は`0x1976a914 {20-byte-key-hash} 88ac`のフォーマットで作成される
  - `19`は後続の 25 バイト（`76a9 ... 88ac`のこと）をスタックにプッシュするという意味 (OP_PUSHBYTES_25)
  - `76a914`、`88ac`はそれぞれ P2PKH で出てきた`OP_DUP OP_HASH160 OP_PUSHBYTES_20`、`OP_EQUALVERIFY OP_CHECKSIG`のことである
  - つまり`<ScriptCode>`は，
    `OP_PUSHBYTES_25 OP_DUP OP_HASH160 {20-byte-key-hash} OP_EQUALVERIFY OP_CHECKSIG`のこと．

- すなわち`ScriptCode`は P2PKH における Locking Script と同じである

- したがって、`<Witness> <ScriptCode>`は P2PKH の`<Unlocking Script> <Locking Script>`と同じ操作である

<!-- todo 同じ操作ってなに？UnlockingSrcriptは空とあるが，ScriptPubKeyには何をいれる？　=> RE: 同じ検証方法に帰結するということです。Unlocking Scriptの中は記載していますが何が不明でしょうか？
P2WPKHのときは式の評価方法が<UnlockingSrcript><LockingScript>とは違うってこと？ => RE: そうです。上記の通り <Witness> <ScriptCode> になります。Witness、ScriptCodeのそれぞれの中身を見てみると、
 <Witness> <ScriptCode> という操作によって、すでに紹介した P2PKH と同じスクリプトが出来上がるという話です。

それをクライアントはどうやって検出する？ => RE: #トランザクションの構造 で説明した任意のFlagによって判別します。## トランザクション方式について で説明したとおり、P2WPKHかP2WSHはLocking Scriptのサイズで判別します。
-->

- 全体の処理としては

  `<Witness> <ScriptCode>`

  `<48 {署名値 72byte} 21 {公開鍵 33byte}> <19 OP_DUP OP_HASH160 14 {20-byte-key-hash} OP_EQUALVERIFY OP_CHECKSIG>`

- 以下に処理の流れを記しておく

  ![P2WPKHの処理の流れ](./img/process_p2wpkh.drawio.svg)

<!-- TODO これの実行をしてどうやって検証されるのか流れを示す必要あり　=> RE: 図を作って説明するということでいいですか？ -->

<!-- todo 何と何を比べればよい？というか全体で3バイトしか節約してなくて，ブロックサイズが1MBから実質4MBまで拡張できているのは納得感がない．
=> RE: 節約して拡張を目的としているわけではないです。逆にUnlocking Scriptが Witnessに移動した分おまけで広くなった程度の認識です。「署名データは最大でトランザクションデータのおよそ 65%ほどを占める」と書きましたが、そこから推しはかるに650,000バイトほど多く使えるようになっただけです。どんなに頑張っても4MBにはなりません。繰り返しますが、データは1MBしか入りません。
-->

- しかし P2PKH と比べてみると、Script Code を使うことで Locking Script が 3 バイト節約できている

  - P2PKH: `OP_DUP OP_HASH160 OP_PUSHBYTES_20 {20-byte-key-hash} OP_EQUALVERIFY OP_CHECKSIG`
  - P2WPKH: `OP_0 OP_PUSHBYTES_20 {20-byte-key-hash}`
  - `OP_HASH160`、`OP_EQUALVERIFY`、`OP_CHECKSIG`がないだけ、3 バイト少ない

### Pay-to-witness-script-hash（P2WSH）

- [P2SH](#pay-to-script-hash-p2sh) の SegWit バージョンが P2WSH である
- P2WSH は 32 バイトのハッシュを使用する
- また、P2SH で Redeem Script と呼ばれていたものは Witness Script と呼ばれる
<!-- todo  P2WPKHと用途は何が違う？ => P2SHのSegWitバージョンなのです。## トランザクション方式について でも言及していますがもう一度書いた方がいいですか？伝わってなさそうなので、## トランザクション方式について の説明を少し変えます -->
- #### Unlocking / Locking Script / Witness のフォーマット

  - Locking Script

    `OP_0 <32-byte-hash>`

    - `<32-byte-hash>`は Witness Script を SHA256 関数に通した値
    - Witness Script は witness の最後のデータのこと（以下 Witness のところを参照のこと）

  - Unlocking Script

    - 空である

  - Witness

    `OP_0 <署名> <WitnessScript>`

    - `<WitnessScript>`は P2SH における Redeem Script のようなものである
    - なので`<WitnessScript>`は`M <公開鍵 1> ... <公開鍵 N> N OP_CHECKMULTISIG`のようになっている（マルチシグの場合）

  - 検証では以下の操作を行う
    <!-- TODO Bitcoinスクリプトですべての処理を記述すべき 上と同様に`<Witness> <ScriptCode>`を評価していっている？　
    => RE: 三段階に分かれているため、P2WPKHとも少し違います。ですが、P2WPKHと同じく、ある段階まで操作が進むとP2SHの処理に帰結します。これも図にしたほうが良いですか？「Bitcoinスクリプトですべての処理を記述すべき」とありますが、WitnessはそもそもBitcoinスクリプトではないので、スクリプトを並べて順に読んでいけば検証完了にたどり着くわけでもありません。それでも <Witness> <Locking Script> をつなげて表記したほうが良いですか？
    -->

    1. `<WitnessScript>`のハッシュ（SHA256）が`<32-byte-hash>`と同じ（True）かを確認する
    2. `True`なら`OP_0 <署名>`がスタックにプッシュされる
    3. `<WitnessScript>`を逆シリアル化して 2 のスタックにプッシュする
    4. 3.の Script が True になれば OK

  - したがって、やってる操作の内容は P2SH と同じである

  - 以下に P2WSH での 2 of 3 のマルチシグを使用する場合の、処理プロセスの例を挙げる

    ![P2WSHの処理の流れ](./img/process_p2wsh.drawio.svg)

# まとめ

- トランザクションは資金残高の移動を表現するデータである
- ブロックチェーンの改ざん耐性により，記録されたトランザクションの永続化を実現している
- Tx は大きく分けて 3 種類
  - 通常のトランザクション
    - 送金トランザクションはここに含まれる
  - Coinbase トランザクション
    - マイニング報酬の支払い
  - Segwit トランザクション
    - 送金 Tx であるが，サイズが圧縮されている
